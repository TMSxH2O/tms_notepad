学习笔记 [深度阅读：深入 C++ 内存管理（万字长文） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/344377490#:~:text=%E8%AF%B4%E5%88%B0%20C++%20%E7%9A%84)

# 1.基础概念
## 1.1.内存布局

进程的结构可以被分为5个部分（从低位到高位）：
 - Code Segement（代码区）<br>也被称为Text Segement，存放可执行程序机器码的部分。
 - Data Segement（数据区）<br>存放已初始化的全局和静态变量，常量数据（如字符串字面量）
 - BBS（Block Started by Symbol）<br>存放未初始化的全局和静态变量（默认都被设置为0）
 - Heap（堆）<br>从低地址向高地址增长。容量大于栈，程序中动态分配的内存在此区域。
 - Stack（栈）<br>从高地址向低地址增长。由编译器（也有说法是系统来维护）自动管理和分配。程序中的局部变量、函数参数值、返回值等都存在此区域。

## 1.2.内存对齐

对于结构体或类，在其大小是其成员变量大小的总和，同时结构体内部成员还会自动进行内存对齐操作

### 为什么需要内存对齐？

1.内存对齐使得数据读取更加高效

从硬件设计上，数据读取的处理器只能从地址为k的倍数（目标数据大小的整数倍）的内存处开始读取数据。这种读取方式相当于将内存分为了多个“块”，如果架设了内存可以从任意位置开始存放的话，数据很可能被分散到多个“块”中，处理分散在多个块中的数据需要移除首位不需要的字节，在进行合并，非常耗时。

为了提高数据读取的效率，程序分配的内存并不是连续存储的，二十按首地址为k的倍数的方式存储；这样就可以一次性读取数据，而不需要额外的操作。

> 读取非对齐内存的处理过程（位域也算）
> 读取所在块的所有数据后，进行mask过滤，再进行移位（本来以为是为了处理大小端问题，但似乎不是？没看懂这步操作），最后进行or合并

2.在特定的平台（CPU）下，不进行内存对齐会导致崩溃

### 内存对齐规则

定义有效对齐值（alignment）为结构体中，最宽成员和编辑器/用户指定对齐值中较小的那个。

1. 结构体起始地址为有效对齐值的整数倍
2. 结构体总大小为有效对齐值的整数倍
3. 结构体第一个成员偏移值为0，之后成员的偏移值为 `min(有效对齐值,自身大小)` 的整数倍

相当于每个成员要对齐，并且整个结构体也需要进行对齐。

## 1.3.内存碎片

程序的内容往往不是紧凑排布的，而是存在很多的碎片。这些内存碎片产生的原因基本可以分为两类：

1. 内部碎片：系统分配的内存大于实际所需的内存（由于对齐机制）；
2. 外部碎片：不断分配回收不同大小的内存，最终由于内存分布散乱，找不到足够大的连续内存进行分配；

为了提高内存的利用率，必须设法减少内存碎片。

TODO 具体的方案（没办法完全避免，通常的做法是减少申请内存的次数，管理已经释放的内存，对空间进行自动合并）

## 1.4.继承类布局

如果一个类继承自另一个类，那么它自身的数据将位域父类之后。

如果当前类或基类中包含虚函数，则会在当前类的最前端占用一个指针的大小（32位上4字节，64位上8字节），用于存储虚表指针（vptr），这个指针指向了一个虚函数表（vtable）。在 vtable 中包含了当前类的所有虚函数指针。

## 1.5.虚拟内存

> 虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有一段连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分割为多个物理内存碎片，还有部分暂时存放在外部磁盘存储器上，在需要时进行数据交换。
> 现代所有用于一般应用程序的操作系统都对普遍的应用程序使用虚拟内存技术，一些老的操作系统，如DOS和1980年代的Windows，或者那么1960年代的大型机，一般都没有虚拟内存的功能。
> by 维基百科

虚拟内存是用来解决物理内存所存在的如下各种问题：

1. 内存空间利用率的问题<br>各个进程对内存的使用会导致内存碎片化，当分配一块很大的内存空间时，可能出现虽然由足够多的空闲物理内存，却没有足够大的连续空闲内存的情况，导致内存空间的浪费。（物理内存大小的限制）
2. 读写内存的安全性问题（内存的权限控制）<br>物理内存本身时不限制访问的，任何地址都可以进行读写，而现代操作系统需要实现不同的页面具有不同的访问权限，例如只读数据等。
3. 进程间的数据安全问题<br>各个进程之间没有独立的地址空间，一个进程由于执行错误指令或是恶意代码都可以直接修改其他进程的数据，甚至修改内核地址空间的数据，这都是操作系统不愿意见到的。
4. 内存读写的效率问题<br>当多个进程同时运行，需要分配给进程的内存综合大于实际可用的物理内存时，需要将其他程序暂时拷贝到磁盘中，然后将新的程序装入内存运行。由于大量的数据频繁装入装出，内存的使用效率会非常低。

### 缺页

在虚拟内存中，每个程序的地址空间被划分为多个块，每个内存块被称为**页**，每个页包含了一段连续的地址，并作为内存操作的单位加载到物理内存中。但并不是所有的页都直接保存在物理内存中，当我们访问到了不在物理内存中的页，此时就被称为**缺页**，操作系统会从硬盘将对应内容装载到物理内存。当物理内存不足时，其他不活跃的页也会被写回硬盘。

在这里，可以将CPU、高速缓存和主存RAM视作一个整体，统称为 DRAM。由于 DRAM 与硬盘之间的读写也比较耗时，为了提高程序性能，我们依然需要确保自己的程序具有良好的“局部性“——缓存友好设计，减少缺页发生的概率。
