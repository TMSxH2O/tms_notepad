
# 题目描述

> [!tag]- 标签
> #数组 #前缀和

[238. 除自身以外数组的乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked)

![[LeetCode-ProductOfArrayExceptSelf.png|600]]

> [!warning] 注意
>问题中强调了不能使用除法，而且除法也没办法应对元素中存在0的情况 

# 划分上下三角

> [!example]- 实现思路
> 在这个问题中，通过画图构建一个乘法矩阵，可以看到这里的本质是对角线上的值变成1，最后需要的值则是如下 $B_i$ 行（或列）的乘积值。
> $$B_n = \begin{bmatrix}
> 1&\color{red}{A_1}&\color{red}{A_2}&\color{red}{\cdots}&\color{red}{A_n}\\
> \color{yellow}{A_0}&1&\color{red}{A_2}&\color{red}{\cdots}&\color{red}{A_n}\\
> \color{yellow}{A_0}&\color{yellow}{A_1}&1&\color{red}{\cdots}&\color{red}{A_n}\\
> \color{yellow}{\vdots}&\color{yellow}{\vdots}&\color{yellow}{\vdots}&\ddots&\color{red}{\vdots}\\
> \color{yellow}{A_0}&\color{yellow}{A_1}&\color{yellow}{A_2}&\color{yellow}{\cdots}&1\end{bmatrix}$$
> 
> 为了能都到这里的上下三角形的值，可以分别正序、逆序遍历一次，存储对应的值，最后将两个部分的值相乘，就是所需的目标值。

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        const size_t num_count = nums.size();
        vector<int> lhs(num_count, 1), rhs(num_count, 1);
  
        // 正序遍历，整理下三角的值
        for (int i = 1; i < (int)num_count; ++i) {
            lhs[i] = lhs[i - 1] * nums[i - 1];
        }
        // 逆序遍历，整理上三角的值
        for (int i = (int)num_count - 2; i >= 0; --i) {
            rhs[i] = rhs[i + 1] * nums[i + 1];
        }
  
        // 最终的结果，是对应上下三角的乘积
        vector<int> rst(num_count, 1);
        for (int i = 0; i < (int)num_count; ++i) {
            rst[i] = lhs[i] * rhs[i];
        }
        return rst;
    }
};
```

时间性能：$O(N)$，空间性能：$O(N)$

# 优化空间占用

> [!example]- 优化思路
> 上面的基础解法虽然能解决问题，但是空间性能是 $O(N)$，这个理论上也是可以优化的。我们顺着刚才的思路分析，因为每一项的值都是能通过上一项的值迭代得到，所以其实并不需要额外保存到数组。


```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        const int num_count = nums.size();
        vector<int> rst(num_count);
  
        // 从左往右遍历，在rst乘上下三角的值
        int rhs = 1;
        for (int i = 0; i < num_count; ++i) {
            rst[i] = rhs;
            // 通过迭代，最后保存的是应该是 A_1 ~ A_n 的值
            rhs *= nums[i];
        }
        // 从右往左遍历，在rst乘上上三角的值
        int lhs = 1;
        for (int i = num_count - 1; i >= 0; --i) {
            rst[i] *= lhs;
            // 通过迭代，最后保存的应该是 A_0 ~ A_n-1 的值
            lhs *= nums[i];
        }
        return rst;
    }
};
```

时间性能：$O(N)$，空间性能：$O(1)$
