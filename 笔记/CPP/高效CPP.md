> 阅读《Effective C++》过程中所得到的笔记

# 条款30：透彻了解inlining的里里外外

在函数之间传递，为了传递参数，将会利用栈空间，将数据复制到栈空间中进行传递，这个过程就会造成资源的浪费。为了能更加有效得利用空间减少浪费，使用内敛函数（`inline`函数），避免这个部分的资源消耗。

相对的，内敛函数本质上就是代码的复制，这样的方式将会造成代码的膨胀，在另一个方面产生了资源的损耗（从运行时的损耗变为了编译时的损耗）。

## inlining是一个申请

在`C++`中，`inline`关键字的效果是向编译器的一个申请，**希望能够将函数作为内敛函数进行处理**，但实际的情况下，编译器可能忽略部分复杂的情况。

> 大部分编译器会忽略的情况
> - 带有大量循环
> - 递归函数
> - 函数过长
> - virtual函数（虚函数在运行时确定调用的函数，而内敛函数在编译时确认调用函数）

## 内敛函数弊端

内敛函数带来了性能提升的同时，随之而来的却是很多隐藏的问题。

1. 内敛函数的修改必须重新编译所有相关的代码。<br>内敛函数在编译阶段，将函数体的内容复制到对应的位置，如果修改了内敛函数的代码，意味着所有使用到该函数的地方都需要重新编译才能修改，不能像常规函数一样，只需要重新链接即可。
2. 大部分编译器对内敛函数的断点检测支持都存在不足。<br>内敛函数的代码进行复制后，事实上运行时就已经不算是内敛函数中的代码在工作了（可以理解成模板，但并不工作），因此断点并不能正常工作。

因此，在开发阶段不要大量使用内敛函数，避免在之后的更新维护过程产生更大的负担。

## 总结

- 将大多数inlining限制在<span style="color:red;font-weight:bold">小型、被频繁使用的函数</span>上。这样可以使得之后的调试过程和二进制升级（binary upgradability）更加容易，也可以使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。
- 不要只因为function templates出现在头文件，就将它们声明为inline