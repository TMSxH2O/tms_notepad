- [1. 前置知识](#1-前置知识)
  - [1.1. 齐次坐标](#11-齐次坐标)
  - [1.2. 线性变化](#12-线性变化)
  - [1.3. 模型变换](#13-模型变换)
    - [1.3.1. 二维变换](#131-二维变换)
      - [1.3.1.1. 移动](#1311-移动)
      - [1.3.1.2. 缩放](#1312-缩放)
      - [1.3.1.3. 旋转](#1313-旋转)
    - [1.3.2. 三维变换](#132-三维变换)
      - [1.3.2.1. 旋转](#1321-旋转)
- [2. 变换](#2-变换)
  - [2.1. 视图/相机变换](#21-视图相机变换)
    - [2.1.1. 视图变换](#211-视图变换)
    - [2.1.2. 投影变换](#212-投影变换)
      - [2.1.2.1. 正交投影](#2121-正交投影)
      - [2.1.2.2. 透视投影](#2122-透视投影)
        - [2.1.2.2.1. 转换矩阵](#21221-转换矩阵)
        - [2.1.2.2.2. 总结](#21222-总结)
    - [2.1.3. 视口变换](#213-视口变换)
- [3. 光栅化](#3-光栅化)
  - [3.1. 光栅化的处理方法](#31-光栅化的处理方法)
    - [3.1.1. 采样法](#311-采样法)
      - [3.1.1.1. 包围盒优化](#3111-包围盒优化)
  - [3.2. 抗锯齿/反走样](#32-抗锯齿反走样)
    - [3.2.1. 走样的原因](#321-走样的原因)
    - [3.2.2. 现代的抗锯齿方案](#322-现代的抗锯齿方案)
  - [3.3. 阴影](#33-阴影)
    - [3.3.1. 实现](#331-实现)
    - [3.3.2. 软/硬阴影](#332-软硬阴影)
- [4. 着色](#4-着色)
  - [4.1. Blinn-Phong Reflection Model](#41-blinn-phong-reflection-model)
    - [4.1.1. 漫反射](#411-漫反射)
    - [4.1.2. 镜面反射](#412-镜面反射)
    - [4.1.3. 环境光](#413-环境光)
  - [4.2. 着色频率](#42-着色频率)
    - [4.2.1. 法线方向](#421-法线方向)
  - [4.3. 图形管线/实时渲染管线](#43-图形管线实时渲染管线)
- [5. 纹理](#5-纹理)
  - [5.1. UV](#51-uv)
  - [5.2. 纹理贴图](#52-纹理贴图)
    - [5.2.1. 贴图过小/图片放大](#521-贴图过小图片放大)
    - [5.2.2. 贴图采样不足](#522-贴图采样不足)
      - [5.2.2.1. Mipmap](#5221-mipmap)
        - [5.2.2.1.1. 使用方式](#52211-使用方式)
        - [5.2.2.1.2. 优化](#52212-优化)
        - [5.2.2.1.3. 存在的问题](#52213-存在的问题)
      - [5.2.2.2. 各向异性过滤](#5222-各向异性过滤)
        - [5.2.2.2.1. 问题](#52221-问题)
  - [5.3. 其他贴图](#53-其他贴图)
    - [5.3.1. 凹凸贴图](#531-凹凸贴图)
    - [5.3.2. 立体纹理](#532-立体纹理)
- [6. 插值算法](#6-插值算法)
  - [6.1. 重心坐标](#61-重心坐标)
  - [6.2. (双)线性插值](#62-双线性插值)
- [7. 几何](#7-几何)
  - [7.1. 分类](#71-分类)
    - [7.1.1. 隐式几何](#711-隐式几何)
      - [7.1.1.1. 补充内容](#7111-补充内容)
      - [7.1.1.2. 总结](#7112-总结)
    - [7.1.2. 显示几何](#712-显示几何)
      - [7.1.2.1. 面对象文件](#7121-面对象文件)
      - [7.1.2.2. 贝塞尔曲线](#7122-贝塞尔曲线)
  - [7.2. 曲面更新/转化](#72-曲面更新转化)
    - [7.2.1. 曲面细分](#721-曲面细分)
      - [7.2.1.1. Loop细分](#7211-loop细分)
      - [7.2.1.2. Catmull-Clark Subdivision](#7212-catmull-clark-subdivision)
    - [7.2.2. 曲面简化](#722-曲面简化)
      - [7.2.2.1. 边坍缩](#7221-边坍缩)
        - [7.2.2.1.1. 二次误差度量](#72211-二次误差度量)
  - [7.3. 补充内容](#73-补充内容)
- [8. 光线追踪](#8-光线追踪)
  - [8.1. 基础实现](#81-基础实现)
    - [8.1.1. Whitted-Style Ray Tracing](#811-whitted-style-ray-tracing)
  - [8.2. 射线交点](#82-射线交点)
    - [8.2.1. 隐式表面交点](#821-隐式表面交点)
    - [8.2.2. 显示表面交点](#822-显示表面交点)
      - [8.2.2.1. 包围盒](#8221-包围盒)
        - [8.2.2.1.1. 空间划分](#82211-空间划分)
        - [8.2.2.1.2. 物体划分](#82212-物体划分)
- [9. 辐射度量学](#9-辐射度量学)
  - [9.1. 概要](#91-概要)
    - [9.1.1. Radiant Energy and Flux(Power)](#911-radiant-energy-and-fluxpower)
    - [9.1.2. Radiant Intensity](#912-radiant-intensity)
    - [9.1.3. Irradiance](#913-irradiance)
    - [9.1.4. Radiance](#914-radiance)
      - [9.1.4.1. Incident Radiance](#9141-incident-radiance)
      - [9.1.4.2. Exiting Radiance](#9142-exiting-radiance)
  - [9.2. BRDF](#92-brdf)
  - [9.3. 渲染](#93-渲染)
    - [9.3.1. 转换方程](#931-转换方程)
- [10. 路径追踪](#10-路径追踪)
  - [10.1. 概要](#101-概要)
    - [10.1.1. 镜面反射材质](#1011-镜面反射材质)
    - [10.1.2. Monte Carlo Estimator](#1012-monte-carlo-estimator)
    - [10.1.3. 俄罗斯轮盘赌](#1013-俄罗斯轮盘赌)
  - [10.2. 优化](#102-优化)
    - [10.2.1. 反射优化](#1021-反射优化)
    - [10.2.2. 优化光源采样](#1022-优化光源采样)
- [11. 材质和外观](#11-材质和外观)
  - [11.1. 光的传播](#111-光的传播)
    - [11.1.1. 漫反射](#1111-漫反射)
    - [11.1.2. 镜面反射](#1112-镜面反射)
    - [11.1.3. 折射](#1113-折射)
      - [11.1.3.1. 菲涅尔反射/菲涅尔项](#11131-菲涅尔反射菲涅尔项)
  - [11.2. 微表面模型](#112-微表面模型)
    - [11.2.1. 各向异性微表面模型](#1121-各向异性微表面模型)
- [12. 高级光线传播](#12-高级光线传播)
  - [12.1. 分类](#121-分类)
    - [12.1.1. Bidirectional Path Tracing](#1211-bidirectional-path-tracing)
    - [12.1.2. Metropolis Light Transport](#1212-metropolis-light-transport)
    - [12.1.3. Photon Mapping](#1213-photon-mapping)
    - [12.1.4. Vertex Connection And Merging](#1214-vertex-connection-and-merging)
    - [12.1.5. Instant Radiosity](#1215-instant-radiosity)
- [13. 高级外观建模](#13-高级外观建模)
  - [13.1. 非表面材质](#131-非表面材质)
    - [13.1.1. 散射介质](#1311-散射介质)
    - [13.1.2. 毛发](#1312-毛发)
    - [13.1.3. 颗粒材质](#1313-颗粒材质)
  - [13.2. 表面材质](#132-表面材质)
    - [13.2.1. 透光材质](#1321-透光材质)
    - [13.2.2. 布料](#1322-布料)
    - [13.2.3. 高精度材质](#1323-高精度材质)
  - [13.3. 程序生成材质](#133-程序生成材质)
- [14. 计算机动画](#14-计算机动画)
  - [14.1. 关键帧动画](#141-关键帧动画)
  - [14.2. 物理模拟](#142-物理模拟)
    - [14.2.1. 质点弹簧系统](#1421-质点弹簧系统)
    - [14.2.2. 有限元分析](#1422-有限元分析)
    - [14.2.3. 粒子系统](#1423-粒子系统)
      - [14.2.3.1. 单粒子模拟](#14231-单粒子模拟)
        - [14.2.3.1.1. 欧拉方法](#142311-欧拉方法)
        - [14.2.3.1.2. 改进方法](#142312-改进方法)
  - [14.3. 运动学](#143-运动学)
    - [14.3.1. 正运动学](#1431-正运动学)
    - [14.3.2. 逆运动学](#1432-逆运动学)
  - [14.4. Rigging](#144-rigging)
    - [14.4.1. 动作捕捉](#1441-动作捕捉)

> GAMES101-现代计算机图形学入门-闫令琪<br>https://www.bilibili.com/video/BV1X7411F744<br>http://games-cn.org/
>
> **拓展：**<br>3Blue1Brown 线性代数 https://space.bilibili.com/88461692/<br>B-Splines学习 [快速跳转](https://www.bilibili.com/video/av66548502?from=search&seid=65256805876131485)

此处并不绝对针对某个具体的图形开发API，主要需要注意的是其中的思想。默认此处使用的是<span style="color:red">**OpenGL**</span>。


# 1. 前置知识

正式开始之前的准备阶段，主要包括图形变化的概念。

<a id="title-%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87"></a>

## 1.1. 齐次坐标

在计算机中，通常使用向量来表示位置或方向，而向量因为需要同时表示顶点的位置以及某个方向（以及方向的大小）。为了在计算机中对这两者作出区分，将用于表述的向量增加一个维度，默认，当补充的值为0时，表示是一个方向；当补充的值为1时，表示的是一个点。<u>一般的表示方法如下，其中w表示额外补充的维度</u>。

在使用时，只要w不等于0，就将向量各个值同时除以w。

$$
\begin{bmatrix}
x\\y\\z\\w\\
\end{bmatrix}\Rightarrow
\begin{bmatrix}
x/w\\y/w\\z/w\\1
\end{bmatrix}
$$

> **额外维度的引入所带来的影响**
>
> 此处以三维空间中的顶点和方向为例，此处的计算，都需要先将各个位置上的数除以w上的值。
>  - 两个点相减得到一个方向<br>因为w的值变成0，得到的是一个方向
>  - 点加方向得到一个点<br>因为w的值依然是1，等价于从某个指定的点移动方向后，得到一个新的点
>  - 点加点得到的是两点的中点<br>两个点相加之后得到的w为2，之后会对所得到的值除以二（w只有1和0时才能直接表示有意义）
>  - 两个方向之间加或减<br>w的值一直为0，其表示的永远是一个方向

通过引入齐次坐标，可以将平移操作中的操作，使用矩阵进行表示。让平移操作也能使用一个变化矩阵进行表示。

## 1.2. 线性变化

<u>变化前后，坐标中的中心不会发生变化，变化中的坐标轴（以及坐标轴的辅助线）不会相交。</u>

此处主要需要和<span style="color:red">**仿射变换**</span>作出区别。仿射变化的坐标中心发生了变化，但是变化中的坐标轴（以及坐标轴的辅助线）不会相交。最典型的仿射变换就是平移操作。

## 1.3. 模型变换

模型在二维和三维的世界中，通过平移、旋转等操作，使得模型坐标发生变换。此处将分别针对二维和三维的情况进行学习。

### 1.3.1. 二维变换

二维空间下的**线性变化**，引入了w来区分顶点和方向。

> 线性变化的本质
>
> 可以通过向量与某个变化矩阵相乘，并最终得到所需的向量，这样的变化就满足线性变化。
>
> 更加标准的定义应该是**线性变换把一个向量空间里的向量映射到了另一个向量空间里的另一个向量，因此，我们可以把线性变换理解成输入一个向量，然后输出一个向量的特殊函数。**

#### 1.3.1.1. 移动

> 移动操作依赖[齐次坐标](#title-%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87)的使用，如果没有引入齐次坐标，不能很好地表示这种加法的操作

在计算机中，需要表示移动或平移，需要引入一个<span style="color:red">**变化矩阵**</span>，与表示点的向量相乘，并最终得到所需要的结果。

$$
\begin{bmatrix}
x+x_\Delta\\y+y_\Delta\\w
\end{bmatrix}=
\begin{bmatrix}
1&0&x_\Delta\\0&1&y_\Delta\\0&0&1
\end{bmatrix}\cdot
\begin{bmatrix}
x\\y\\w
\end{bmatrix}
$$

> 此处三维的移动同理，没有本质区别

#### 1.3.1.2. 缩放

为了表示二维空间中的缩放，此处将使用S<sub>x</sub>表示x轴上的缩放，<sub>S_y</sub>表示y轴上的缩放。

$$
\begin{bmatrix}
x \times S_x\\y \times S_y\\w
\end{bmatrix}=
\begin{bmatrix}
S_x&0&0\\0&S_y&0\\0&0&1
\end{bmatrix}\cdot
\begin{bmatrix}
x\\y\\w
\end{bmatrix}
$$

通过《线性代数的本质》中，所提到的只是，其变化矩阵中（此处没有考虑额外的维度），<u>第一列就是x轴上的单位矩阵，而第二列就是y轴上的单位矩阵</u>。因此，也可能出现以下的形式（此处省略w）。

$$
\begin{bmatrix}
x \times \hat{i}_x + x \times \hat{j}_x \\
y \times \hat{i}_y + y \times \hat{j}_y
\end{bmatrix}=
\begin{bmatrix}
\hat{i}_x&\hat{j}_x\\\hat{i}_y&\hat{j}_y
\end{bmatrix}\cdot
\begin{bmatrix}
x\\y
\end{bmatrix}
$$

> 三维的缩放同理

#### 1.3.1.3. 旋转

平面内的线性旋转，其中默认，<u>旋转的中心为原点，旋转的方向为逆时针</u>。

按照《线性代数本质》中的理解，如果进行旋转，单位向量的变化如下：

$$
\because假定旋转的角度为\theta\\[2ex]
\hat{i}:
\begin{bmatrix}
1\\0
\end{bmatrix}
\Rightarrow
\begin{bmatrix}
cos\theta\\sin\theta
\end{bmatrix}\\[2ex]
\hat{j}:
\begin{bmatrix}
0\\1
\end{bmatrix}
\Rightarrow
\begin{bmatrix}
-sin\theta\\cos\theta
\end{bmatrix}
\\[2ex]
\therefore组合形成最终的变化矩阵\\[2ex]
\begin{bmatrix}
cos\theta&-sin\theta\\sin\theta&cos\theta
\end{bmatrix}
$$

### 1.3.2. 三维变换

基本与二维类似，此处不再重复，主要区分其中的旋转。

#### 1.3.2.1. 旋转

在三维空间中的旋转，可以与二维的旋转进行比较，可以将二维作为其中的一面进行理解，将其拓展到三维空间中。

为了方便三维空间中表示不同的旋转，此处引入欧拉角，以三个坐标轴为旋转中心轴进行旋转，分为俯仰角（Pitch，z轴）、偏航角（Yaw，y轴）和翻滚角（Roll，x轴）。

> 各个轴默认的旋转方向需要根据其使用的是左手坐标系和右手坐标系进行区分（右手定则）。

$$
x轴旋转（Roll）\\[2ex]
\begin{bmatrix}
1&0&0&0\\
0&cos\theta&-sin\theta&0\\
0&sin\theta&cos\theta&0\\
0&0&0&1
\end{bmatrix}\\[2ex]
y轴旋转（Yaw）\\[2ex]
\begin{bmatrix}
cos\theta&0&sin\theta&0\\
0&1&0&0\\
-sin\theta&0&cos\theta&0\\
0&0&0&1
\end{bmatrix}\\[2ex]
z轴旋转（Pitch）\\[2ex]
\begin{bmatrix}
cos\theta&-sin\theta&0&0\\
sin\theta&cos\theta&0&0\\
0&0&1&0\\0&0&0&1
\end{bmatrix}
$$

> 欧拉角和旋转矩阵之间的转换存在一定的问题，最好还是应该转换为<span style="color:red">**四元数**</span>进行分析

根据上方的旋转，可以推导出旋转的公式（罗德里格斯公式）

$$
围绕着过原点的向量n逆时针旋转\alpha\\[2ex]
R(n,\alpha)=cos(\alpha)I+(1-cos(\alpha))nn^T+sin(\alpha)\underbrace{\begin{pmatrix}0&-n_z&n_y\\n_z&0&-n_x\\-n_y&n_x&0\end{pmatrix}}_{N}
$$

# 2. 变换

模型或物体在从描述它的世界坐标中，逐步投影转换到屏幕上的过程。

## 2.1. 视图/相机变换

View/Camera Transformation，视图与相机的变换，将各个模型整合并最终转换到一个显示的平面中。

> 这个过程可以参考OpenGL中的处理过程

此处可以按照拍照的过程进行理解：
1. 拍照的人站在合适的位置（**Model transformation**，模型转换）
2. 将相机放在合适的角度（**View transformation**，视图转换）
3. 拍照，将3D的图像保存在2D的图片中（**Projection transformation**，投影转换）

### 2.1.1. 视图变换

在视图变换中，将会决定相机的基本属性：
- Position 位置
- Look-at/gaze direction 相机方向
- Up direction 上方向

> 相机中的属性中，相机的姿态（向上方向）将会影响最终的图像，因此必然需要指定一个上方向。

在视图变换的过程中，根据相机的状态，将会得到所需的值，因此为了之后方便理解，将相机看作整个系统的中心（原点），相机的方向永远作为-Z的方向，相机的上方向永远看作+Y方向。

### 2.1.2. 投影变换

- 正交投影
- 透视投影

![projection-transform](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/projection-transform.png)

#### 2.1.2.1. 正交投影

正交投影，Orthographic Project，将空间内的物体，向某个平面进行压缩所得到的结果。

> 例（简化版）：<br>
> 将相机放在原点，看向-Z方向，上方向为+Y 将范围内，所有点的Z值删除，将转化得到的结果放入[-1, 1]的平面内
> <hr>
> <b>隐含的问题</b><br>
> 通过这种方式压缩得到的图案，并不能判断各个图案的深度（上下覆盖关系）

标准的正交投影过程中，需要指定投影矩阵三个方向的范围。
- 左右[left, right]
- 上下[top, bottom]
- 远近[far, near]

> 此处需要注意，因为右手坐标系，相机的方向是-Z方向，因此far应该小于near。

对三个范围进行映射，并最终得到一个[-1, 1]的标准立方体。转换的矩阵如下：

$$
M_{ortho}=\begin{bmatrix}\cfrac{2}{r-l}&0&0&0\\0&\cfrac{2}{t-b}&0&0\\0&0&\cfrac{2}{n-f}&0\\0&0&0&1\end{bmatrix}\begin{bmatrix}1&0&0&-\cfrac{r+l}{2}\\0&1&0&-\cfrac{t+b}{2}\\0&0&1&-\cfrac{n+f}{2}\\0&0&0&1\end{bmatrix}
$$

#### 2.1.2.2. 透视投影

透视投影，Perspective Projection，是为了能够在二维显示更加真实的三维图像的一种处理方法。它具有消失感、距离感、相同大小的形体呈现出规律的变换等一系列的透视特性，能够更加逼真地反映形体的空间形象。

此处，为了减少透视矩阵推理的难度，将其拆分为两个步骤：
1. 将透视投影的立方体压缩并转换为正交投影的范围（转换矩阵）
2. 利用正交投影来得到投影的结果（正交投影）

此处的难点，就是推导出透视矩阵到正交矩阵的转换矩阵。

##### 2.1.2.2.1. 转换矩阵

推导过程如下：

![透视矩阵变化](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/projection-matrix-point.png)

$$
按照上图，上图可以得到其中任意一个点P与压缩成正交矩阵中对应关系：\\[2ex]
M_{persp\to ortho}\begin{pmatrix}x\\y\\z\\w\end{pmatrix}\Rightarrow\begin{pmatrix}\cfrac{n}{z}x\\\cfrac{n}{z}y\\?\\1\end{pmatrix}=\begin{pmatrix}nx\\ny\\?\\z\end{pmatrix}\\[2ex]
\\通过上方的变化，可以得到矩阵的部分应该为。\\[2ex]
\begin{bmatrix}n&0&0&0\\0&n&0&0\\?&?&?&?\\0&0&1&0\end{bmatrix}\\[2ex]
观察透视模型和正交模型中，近平面（整个平面）与远平面中点在变化的过程中都不会发生变化。\\[2ex]
将这两点带入可以得到：\\[2ex]
M_{persp\to ortho}\begin{pmatrix}x\\y\\n\\1\end{pmatrix}=\begin{pmatrix}nx\\ny\\n^2\\n\end{pmatrix}\\[2ex]
此处，假定还未知的行为: \begin{pmatrix}A&B&C&D\end{pmatrix}\\[2ex]
\because Ax+By+Cn+D=n^2\\[2ex]
\therefore \begin{cases} A=B=0 \\ Cn+D=n^2 \end{cases}\\[2ex]
将远平面中点带入，可以得到：\\[2ex]
M_{persp\to ortho}\begin{pmatrix}0\\0\\f\\1\end{pmatrix}=\begin{pmatrix}0\\0\\f^2\\f\end{pmatrix}\Rightarrow Cf+D=f^2\\[2ex]
结合已知的数据，可以得到以下的式子:\\[2ex]
\begin{cases}Cf+D=f^2\\Cn+D=n^2\end{cases}\Rightarrow\begin{cases}C=n+f\\D=-nf\end{cases}\\[2ex]
M_{persp\to ortho}=\begin{bmatrix}n&0&0&0\\0&n&0&0\\0&0&n+f&-nf\\0&0&1&0\end{bmatrix}
$$

##### 2.1.2.2.2. 总结

通过在转换矩阵中的推导，得到了将透视矩阵转换为正交矩阵，并最终使用正交矩阵的来进行透视的方法，因此透视矩阵的拆解如下：

$$
M_{persp}=M_{ortho}M_{persp\to ortho}
$$

### 2.1.3. 视口变换

在视图/相机变换的基础上，为了将图像显示在屏幕上，需要将其转换到<span style="color:red">**标准屏幕坐标系**</span>中。

> 通常此处会有一层额外的封装，将其转换到[0, 1]。具体的转换由内部的API实现。

$$
需要将原本的[-1, 1]的矩阵，转换到[width, height]屏幕坐标系中\\[2ex]
M_{viewport}=\begin{bmatrix}\cfrac{width}{2}&0&0&\cfrac{width}{2}\\0&\cfrac{height}{2}&0&\cfrac{height}{2}\\0&0&1&0\\0&0&0&1\end{bmatrix}
$$

# 3. 光栅化

光栅化，Rasterization，表示将所得到的图案，转换为像素（图元）的过程。在图形学中的，第一个重点内容，关系到图像的呈现。

> **为什么图元选择了三角形？**<br>
> 三角形具有很多优秀的性质：
> 1. 任何的多边形都可以被拆分为多个三角形
> 2. 三角形中的所有组成部分（包括顶点和边）可以被放到同一个平面中
> 3. 三角形不存在凹凸问题（内外测判断更加清晰）
> 4. 三角形可以对其内部的任何一点点得到一种线性的变换（更加方便实现光栅化）

## 3.1. 光栅化的处理方法

目前已经存在很多不同的处理方式，将逻辑中的图像，通过特定的逻辑，转换为像素列表输出到显示设备进行显示。

### 3.1.1. 采样法

> <span style="color:red">**采样**</span><br>
> 对一个连续的函数进行取值，使其离散的过程，就被称为采样。

最简单，最经典的处理方式，将通过在各个假想的像素方格内进行采样，来决定像素的颜色。

最基础的思路，通过遍历像素，并判断中心点的颜色，从而获取像素的颜色。

#### 3.1.1.1. 包围盒优化

在采样法中，将会涉及到遍历像素的操作，导致性能降低，为了提高性能，需要尽可能减少遍历的大小，通过限定一个**包围盒**。根据三角形的三个顶点，可以得到一个最左下角的点和最右上角的点，由这两个点限定的范围就被称为包围盒。

三角形不可能超出包围盒的范围，而包围盒外也不可能有三角形的内容。通过这样的方式，减少了循环的大小，提高了性能。

![包围盒原理示意图](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/%E5%85%89%E6%A0%85%E5%8C%96-%E9%87%87%E6%A0%B7%E7%82%B9-%E5%8C%85%E5%9B%B4%E7%9B%92%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

> 黄色三角形为所需的三角形，根据三角形得到对应的包围盒（蓝色的矩形范围），最外侧的白色是包围盒外部（不需要考虑的部分，提升性能）

## 3.2. 抗锯齿/反走样

因为像素是一个个方块，将连续图像转换为像素之后，会出现方块与原图案差异较大的情况，为了减少这种误差（主要是像素导致的大量锯齿aliasing），就涉及到了抗锯齿/反走样anti-aliasing。

之所以出现走样的问题，本质上是信息在采样的过程中出现了丢失。

> **模糊走样 Blurred Aliasing**
>
> 一种反走样处理方案，在进行采样之前，先进行模糊操作。<span style="color:red">其中模糊操作和采样操作的顺序不能交换。</span>
>
> 本质上就是对图像进行降频，之后再进行采样的方式。

### 3.2.1. 走样的原因

详细了解，此处将涉及到频域、傅里叶变换的内容。

> - 频域，Frequency Domain
> - 傅里叶变换，Fourier Transform，任何的函数，都可以使用正/余弦函数的变换进行表示

此处以不同频率的余弦进行采样并测试，发现其中频域越高信息丢失越多。因为在采样的过程中，频域相差越大，其产生的误差也越来越大。

![高频丢失](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/%E5%8F%8D%E8%B5%B0%E6%A0%B7-%E8%B5%B0%E6%A0%B7%E7%9A%84%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3.png)

<span style="color:red">**走样的定义**</span>：<u>使用相同的方法（采样规则）进行采样，对两个完全不同的对象取得了相同的结果，这就是发生了走样。</u>

同样的，也可以看出，为了能够得到更高频的信号（指变化更加迅速的信息），就不得不增加采样点，才能保证得到的信息不走样。

### 3.2.2. 现代的抗锯齿方案

- MSAA 过采样/多采样<br>在像素中，使用更多的采样点，来辅助判断像素颜色，进行混合得到最终结果
- FXAA {快速抗锯齿}<br>在原本未处理（锯齿图像）的基础上，对锯齿进行柔和处理，从而减轻锯齿
- TAA {多帧采样}<br>使用之前帧的缓冲，共同决定当前像素的结果
- DLSS 深度学习采样<br>利用深度学习技术进行采样

## 3.3. 阴影

阴影是能够让世界变得更加真实的一项重要的工具，缺少了阴影可能导致物体漂浮等错误，而之前的物体上的阴影只是局部的阴影，而此处将解决的是**全局的阴影**。

阴影的问题比较复杂，通过现实中的常识，可以将阴影的问题进行转换：相机能到达，而光源不能到达的点，就是阴影。

### 3.3.1. 实现

目前的一种全局阴影实现，是通过深度映射的方式：

1. 将相机放在光源处，对光所能到达的区域进行截图，得到类似深度缓冲的结果。从光源处，经过假想的像素平面，经过平面上的像素并计算这条射线的最近交点，在对应像素中存放这个距离。
2. 在真正的相机位置进行判断，将对应的位置向光源做连线，对应位置到光源的距离，如果与光源处对应（之前深度测试的时候，存放各个位置的深度）的深度是否一致，如果不一致，说明光源不能到达指定的位置，就会形成阴影。
3. 重复步骤2，最终对所有的位置进行检查。

最终形成一张阴影图，此处还隐藏了很多的细节的问题，如阴影图的分辨率，如果阴影图的分辨率过低，会出现明显的锯齿；在距离判断的过程中，因为使用了浮点数，导致其真正的判断结果可能会存在一定的误差，导致明暗交界轮廓并不清晰等。

### 3.3.2. 软/硬阴影

通过软/硬阴影，来分别表示部分场景中，阴影轮廓的明暗划分是否清晰。软阴影表示阴影的划分模糊，而硬阴影则是明暗交界非常清晰。

![高频丢失](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/total-solar-eclipse-com.png)

通常情况下，如果光源存在一定的大小，出现的都应该是软阴影，通过遮光物体与光源进行连线，可以将阴影分为三个部分。其中，没有任何光可以到达的部分，被称为本影，而其他部分光源可以到达的范围，被称为半影。

# 4. 着色

> 在字典中，大概将其定义为，引入明暗、颜色的过程。

此处，将<span style="color:red">**着色**</span>定义为：<u>对不同的物体，应用不同材质的过程。</u>

在着色阶段，只关心其局部（在本应该被阴影覆盖的区域进行着色，并不在意外部因素，此处为光照，只关心本身的颜色）。

## 4.1. Blinn-Phong Reflection Model

> 在Phong光照模型基础上进行了优化，增强其效果。主要体现在镜面反射的处理中，添加了一个分量，让镜面反射不会简单的进行最少的直接反射，没有正对的位置也可以存在一定的镜面反射效果。

一个简单的光照模型，其中将光照简单分为三种类型：

- 环境光 Ambient lighting
- 漫反射 Diffuse reflection
- 镜面反射 Specular highlights

> 定义部分变量（单位向量）：<br>
> - 观测方向 Viewer direction, v
> - 平面法线 Surface normal, n
> - 光照方向（光照的反向，方便计算） Light direction, l
> - 其他（平面的参数，如颜色、光泽度等）

### 4.1.1. 漫反射

漫反射的强度，由以下几个因素共同决定：
- 光照强度（光源颜色）
- 光照与平面法相的夹角（夹角越小漫反射越强）
- 光传播的距离（光源到物体）

<span style="color:white; background-color:DimGray">此处光传播的距离并<span style="color:red;font-weight:bold">不考虑</span>物体到相机的距离</span>

通过以上的因素，可以得到大致的公式：

$$
L_d=k_d(I/r^2)max(0, n \cdot I)
$$

> - $L_d$ 表示漫反射光
> - $k_d$ 表示漫反射因素，由表面材质等各项因素影响

### 4.1.2. 镜面反射

在 Blinn-Phong 反射模型中，对镜面反射进行了优化（相比起原本Phong反射模型），如果是不太光滑（与镜子的完全反射相比）的物体进行镜面反射时，应该是在接近反射角的一个范围内，能够看到高光（有一定的分散）。即++当观测的方向与反射出的光线的方向足够接近的时候，就可以看到高光++。

在 Blinn-Phong 反射模型中，对其进行了一定的转换，相比起比较反射出的光线的方向，直接使用<span style="color:red">**半程向量**</span>与法线判断接近即可。

<a id="%E5%8D%8A%E7%A8%8B%E5%90%91%E9%87%8F"></a>
> **半程向量**：<br>通过使用`l`（光源方向）和`v`（观测方向），得到两者的中间角（角平分线）。

$$
h_{(半程向量)}=bisector(\vec{v},\vec{l})=\cfrac{\vec{v}+\vec{l}}{||v+l||}\\[2ex]
L_s=k_s(I/r^2)max(0, n\cdot h)^p\\[2ex]
$$
> - $k_s$ 表示镜面反射系数
> - $p$ 表示高光系数，半程向量与法线方向的夹角与镜面光的强度呈现的是指数型的变化（在非常接近的时候变化明显，之后变换会非常平缓）

### 4.1.3. 环境光

环境光表示在场景中，光通过多次反射，使得某些不会有光线直射的区域也有一定的亮度。在物理世界中讨论这个问题非常复杂，在该模型中，对其进行简化（按照经验），假设++场景中的任意位置的环境光强度都相同，由环境光的系数来决定强度。++

$$
L_a=k_aI_a
$$

> - $L_a$ 表示的是环境光
> - $k_a$ 表示环境光因素

> 这是一个非常大程度上的简化，只是在近似，但与实际的场景相差较大，真实场景需要应用到**全局光照**的知识。

## 4.2. 着色频率

对同一个物体，其本质上是通过多个形状组合形成的完整的物体。按照其转换的过程，就可以将其简单分为三个阶段：

1. **Flat Shading 逐面着色**<br>直接以图元进行着色（如直接以三角形为单位进行着色）。<br>最终得到的物体每个平面中颜色将完全一致，同时各个平面或者图元差异较大（棱角，细节少）
2. **Gourand Shading 逐顶点着色**<br>对其中的顶点进行着色，之后通过插值法，得到平面内的细节。<br>利用插值法能够根据顶点的值，平滑的得到平面内任意位置的值，这样的方式（相较而言更加平滑）
3. **Phong Shading 逐像素着色**<br>每个像素进行着色<br>最柔和的着色，但是性能消耗较大

### 4.2.1. 法线方向

在**顶点着色**中，需要对各个顶点进行着色，此处必然需要顶点对应的法线。因为这个物体的形状，事实上并不是真正想要的形状（物体的形状通过很多的三角形组成，依然是棱角分明的形状与期望的形状其实并不相同），而此处计算希望拿到的是真实的法线。

为了能够实现这样的功能，此处将利用与其向量的各个平面的法线，共同决定顶点处的法线方向。

- 理想状态，顶点法线方向取所有相连平面的法线平均
- 更加合理的情况，应该是取代权平均值

在**像素着色**中，需要对各个像素进行着色，同样需要知道各个像素上的法相方向。在**顶点着色**的基础上，因为已经得到了其顶点的法线方向，需要可以得到各个像素上平滑变换的法线方向，就需要使用到<span style="color:red">**中心坐标法**</span>。

## 4.3. 图形管线/实时渲染管线

图形渲染管线，Graphic Pipeline，表示<u>通过传入的顶点以及各种数据，通过一系列的处理，得到的展示的图像这个过程</u>。

1. 输入顶点数据（3D）
2. 转换并得到对应的屏幕坐标（3D转2D）
3. 通过顶点构建形状
4. 光栅化得到像素
5. 着色
6. 得到图案（拼接等一系列过程）

# 5. 纹理

在图形学中，着色关注的主要是光线的明暗以及上色的过程，纹理基本上就是决定了物体应该如何上色，将2D的图案贴到3D的物体上。

## 5.1. UV

在渲染的过程中，可能会涉及到对物体进行贴图，将2D的图像放到3D的物体上。为了实现这个过程，需要将物体的网格进行展开，这个过程被称为UV展开。

> 因为通常将展开的纹理放在U/V的坐标系中，因此被称为UV

展开UV网格，指的就是切割UV网格的接缝，然后沿着接缝展开的过程。在这个过程中，尽可能保证网格不会发生变形，保证可以正常对应并还原回立体的图像。

## 5.2. 纹理贴图

纹理本质上就是使用了一张二维的图片，通过顶点对应并最终贴到三维物体的表面。此处将使用到插值算法，利用三个顶点的对应关系来计算得到三角形中的各个位置与贴图中的对应关系。

### 5.2.1. 贴图过小/图片放大

贴图过小或者遇到需要放大图片的情况，需要在原本的一整个像素之间，在得到更多的信息（原本的4个像素希望扩大成9个像素）。可以使用插值算法（具体内容可见[(双)线性插值](#title-%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC)），通过相邻的像素矩阵，推导出新采样点的值。

### 5.2.2. 贴图采样不足

如果一张图片，不管放得再远，都使用同一个大小，希望将这张图片放到一个像素大小依然显示其中的内容。这将会导致典型的贴图采样不足问题，如在远处的图像，出现摩尔纹或是频繁闪烁。

这种情况可以使用过采样（增加采样点MSAA）的技术解决，但是将会必然会造成性能的加倍损耗。

为了提高效率，此时的目标是：<span style="color:red">**如何快速获取一个范围内的平均值作为像素输出？**</span>

> 获取像素值的过程，本质上是求出在像素范围，最能表现其性质的值，通常是平均值

为了实现这样的功能，出现了Mipmap（本质上是生成更小的复制贴图并进行拼接），能够明显缩小求搜索的范围，加快计算的速度，同时得到一个近似的值。

#### 5.2.2.1. Mipmap

出现的Mipmap（图像金字塔）是为了能更快速地得到像素的值，其具有以下三个特点
- 快速
- 近似
- 矩形（正方形，最终收缩到一个像素）

##### 5.2.2.1.1. 使用方式

在实际的场景中，为了使用Mipmap，就需要首先知道，贴图中的像素与即将用于显示的像素数量之间的关系，利用这样关系，使用不同程度的Mipmap图案作为最终的值。

![纹理-Mipmap-计算映射关系](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/纹理-Mipmap-计算映射关系.png)

通过插值算法，可以利用顶点与贴图UV上的对应关系，转换得到贴图中的对应关系，通过这样的理解，就可以利用显示像素的位置，推理其在贴图UV上的位置，利用相邻的像素进行投影，计算UV图上的相对位置得到最长边正方形的边，此处为了方便，==假定==投影之后的像素依然为正方形，边长就是与响铃投影像素的最大距离。

为通过得到的映射正方形所覆盖的贴图UV像素，就可以得知需要进行几次缩放的Mipmap图。如，<u>矩形覆盖了4个像素（2*2），则说明其需要进行了一次缩放的Mipmap，正好是上图左侧式子（带入2）所得到的值</u>。

##### 5.2.2.1.2. 优化

使用Mipmap，各个层之间的贴图质量相差较大，如果直接放在一起，效果将会显得十分割裂，为了解决这个问题，依然需要利用到插值算法，得到一个变化更加自然的层与层之间的过渡。

在双线性插值的基础上，在两层之间的结果再次进行插值，被称为<span style="color:red">**三线性插值**</span>。

##### 5.2.2.1.3. 存在的问题

利用Mipmap处理远处的场景时，出现了远处场景完全模糊的情况，这一般是因为在Mipmap的获取过程中，采取了太多的近似，导致值的差异过大。同时，因为Mipmap只能处理正方形区域，而不能处理其他的形状，也将导致结果的精度降低。

其中，尤其是通过像素位置，对贴图UV进行映射的过程中，实际的情况很可能是映射为了一个变形的四边形，而不是原本的正方形。在Mipmap的处理中，将其直接近似为正方形，导致其采取到了很多错误的值又错过了很多正确的值。

为了解决这个问题，出现了<span style="color:red">**各向异性过滤**</span>技术。

#### 5.2.2.2. 各向异性过滤

各向异性过滤，Anisotropic Filtering（也被称为Ripmap） ，是用来过滤、处理当视角变化导致3D物体表面倾斜时造成的纹理错误。传统的双线性和三线性过滤技术都是指“Isotropy”（各向同性，为了是将图片最终压缩至一个像素）的，其各方向上矢量值是一致的，就像正方形和正方体。

在之前的Mipmap中，通过使用像素位置，得到贴图上的映射过程中，将映射的结果近似为了一个正方形，而实际的情况很可能是映射为了一个变形的四边形，而不是原本的正方形。各向异性过滤能够快速得到其他形状的图案，从而减少了在这个近似过程中造成的误差。

![纹理-各向异性过滤-效果演示](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/纹理-各向异性过滤-效果演示.png)

> 各向异性，其核心就在对不同的方向，有不同的变化过程，而这也使得它能够更好得处理映射过程中的拉伸等情况，更加接近真实映射结果

##### 5.2.2.2.1. 问题

各向异性过滤的引入，解决了部分像素矩形拉伸的查询问题，然而在遇到像素不规则变形的情况依然棘手（像素倾斜的四边形，不能用水平或竖直的矩形很好得映射），依然不能完美解决问题。

## 5.3. 其他贴图

贴图除了作为表示物体表面纹理的功能之外，其本质的功能只是提供了一个物体表面的数据映射，因此，纹理也可以用作其他功能。

### 5.3.1. 凹凸贴图

**贴图表示的是物体各个点在进行映射时的高度关系。**

此处需要与位移贴图做出区分，<u>凹凸贴图只会影响漫反射的结果，而位移贴图会真正移动顶点的位置。</u>

因此，使用凹凸贴图的物体边缘依然会表现出原本的性质，如球体的边缘依然是球体，没有凹凸；而使用位移贴图会真正导致物体形状的变换，这会让之后的一系列操作（如阴影计算）所得到的的结果更加真实。

但是，++使用位移贴图就要求物体的形状更加精确（面更多）++。因为位移贴图修改的是物体的顶点，而平面内需要结合顶点的值进行变换（插值）。

此处怀疑是，如果不增加面，单纯通过贴图和顶点来计算位移后的坐标所带来的性能消耗更大，得不偿失（大概）

> DirectX 中，为了结果位移贴图中，为了减小位移贴图的性能消耗，提出了一种新的方式：<span style="color:red">**动态曲面细分**</span>。
>
> 它可以动态分析某个平面，为了适应位移贴图，是否还需要进一步切分平面，以此来使用尽可能少的面来利用位移贴图。

### 5.3.2. 立体纹理

立体纹理，或者说3D的纹理，其表示的不只是物体表面的值，其中还可以计算出物体内部某个位置的值。

这样的效果通过使用<span style="color:red">**“噪声算法”**</span>实现。

# 6. 插值算法

为了能够得到在图形中**平滑过渡**的任意一点所代表的值，需要使用到插值算法。

很多时候会涉及到，通过图像的顶点，得到图形内某个点的值，这样的情况，为了能够让图形内部的值变化更加自然，就需要使用到插值算法。

## 6.1. 重心坐标

重心坐标是为了实现三角形内的插值算法。

核心思想：在三角形平面中的任意一个点，都可以表示为三角形顶点的特定组合进行表示。

在三角形平面中的某个点(x,y)，一定可以表示成以下的关系

$$(x,y)=\alpha A+\beta B+\gamma C$$

如果其中的$\alpha+\beta+\gamma=1$，则可以将$(\alpha,\beta,\gamma)$看作一个点，用于代表(x,y)

<span style="color:red">如果点在三角形内，还需要满足$\alpha$、$\beta$、$\gamma$都非负；反之，点在三角形外</span>

通过上方的规则，就可以使用三个顶点之间的关系，来表示三角形平面内的所有顶点。为了得到三个参数，可以使用面积法：从指定的点向三角形的三个顶点连线，将得到三个三角形（不考虑重合、共线的情况）。此时规定，各个顶点，对应的是与其不相邻的三角形的面积（如顶点A对应的较远的三角形就是A面积），则面积与变量之间的关系可以通过以下公式得到：

$$
\alpha=\cfrac{A_A}{A_A+A_B+A_C}\\\beta=\cfrac{A_B}{A_A+A_B+A_C}\\\gamma=\cfrac{A_C}{A_A+A_B+A_C}\\[2ex]
化简后：\\[2ex]
\begin{align*}
\alpha&=\cfrac{-(x-x_B)(y_C-y_B)+(y-y_B)(x_C-x_B)}{-(x_A-x_B)(y_C-y_B)+(y_A-y_B)(x_C-x_B)}\\
\beta&=\cfrac{-(x-x_C)(y_A-y_C)+(y-y_C)(x_A-x_C)}{-(x_B-x_C)(y_A-y_C)+(y_B-y_C)(x_A-x_C)}\\
\gamma&=1-\alpha-\beta\end{align*}
$$

通过得到的三个关系，将顶点的属性按照比例分配，得到就是这个点上的对应属性。

> 投影之后的物体，并不适用重心坐标，因此，此处的前提必然是在投影之前进行使用

<a id="title-%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC"></a>

## 6.2. (双)线性插值

通过像素的信息，尝试补充部分细节，通过线性插值的方式，来尽可能让这个变化更加柔和。

如，遇到了图像放大（贴图过小）的情况，此处如果是简单得放大各个像素，最终得到必然能看到图像中像素（方块）的痕迹很明显，为了减轻这个程度，就可以使用到**线性插值**的技术。

线性插值，就是<u>假定属性在某一条线段上线性变化，通过点与两端之间的关系，通过两端的值，来得到最终的点上的属性</u>。

![插值算法-线性插值-双线性插值](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/插值算法-线性插值-BilinearInterpolation.png)

对某个进行放大后新的采样点进行采样时，使用周围的4个像素，对其分别做水平和竖直两个方向的切线，分别可以得到新采样点在UV坐标中，与像素点中点连线之间的交点。分别计算在两条线段中的比例，按照比例，混合四个像素的值，最终得到的就是在新采样点更加平滑变化的值。

# 7. 几何

为了能够在机器中，还原和模拟现实中的场景或物体，因为性能的限制，必须采用几何的知识对这个过程进行简化，减轻机器运算的压力，使其可以更快得到想要的结果。而几何，在这个过程中担任了重要的作用。

## 7.1. 分类

根据其几何的表示方式不同，将其分为了：

- **隐式几何 Implicit Geometry**<br>得到的是一个关系，而不是具体的值。如可以使用一个式子来表示哪些点在球面上，因此只能通过带入具体的值，这个式子才有意义，用于得到点与球面的关系。
- **显示几何 Explicit Geometry**<br>与隐式几何中无法确定具体的值相对应，显示几何中已经得到了具体的值或某种映射关系。如之前的所有顶点以及UV图中的映射关系，这就是一种显示几何。

> 直观理解（可能不准确），如果此时有某个`f(x,y)`，可以具体知道对应的结果如`2x`和`x+y`，这就是显示几何；而隐式几何则是一种对应关系，并不能转换为显示几何的形式，以`f(x,y)`为例，隐式几何中，其有可能表示为`f(x,y)=1`表示的是一种关系。

### 7.1.1. 隐式几何

隐式几何表示的是一种关系，其最经典的应用就是通过对很多基础物体的组合，得到新的物体，称为<span style="color:red">**布尔组合**</span>。

![几何-隐式几何-物体布尔组合](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/几何-隐式几何-物体布尔组合.png)

其中通过不同的基础几何形体的组合，最终可以表示出非常复杂的形状，一般用于工程制图。

之后，还有一种比较常见的隐式几何的使用方式，也就是<span style="color:red">**距离函数**</span>。其中通过函数，表示物体各个点，到另一个物体的最小距离，如果距离小于零，则表示在物体内部。

![几何-隐式几何-距离函数](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/几何-隐式几何-距离函数.png)

简单理解，如果此时涉及到求出物体移动的中间状态，通过之前的线性计算，通过起始帧和结束帧两帧的值求平均，得到的实际上并不是此处想要的中间状态，而是起始状态和结束状态的叠加状态。此处可以利用距离函数（此处可以按照等势线理解），得到在起始状态的物体与结束状态物体的距离，使用这个距离的值进行得到，得到就是正确的物体移动中间态，思路大概类似下图。

![几何-隐式几何-距离函数实例](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/几何-隐式几何-距离函数实例.png)

而实际的使用中，隐式几何的结果处理方式也和上图类似，为其想象各个等势线，最终在结合双线性插值来得到一个变化的曲线，并作为最终的结果。

#### 7.1.1.1. 补充内容

- 分形 Fractals<br>整体是由部分的重复递归得到的，应用较少

#### 7.1.1.2. 总结

优点：
- 表述很容易，通常使用一个公式就能表述
- 支持判断包含关系，隐式几何本质上就是一个表示位置关系的公式，很容易得到他们的包含关系
- 方便进行光线的计算
- 可以很好得描述简单的形状，同时可以保证其各个具体的细节都没有异常

缺点：
- 对复杂的形体表示会十分困难

### 7.1.2. 显示几何

显示几何表示一种转换关系（隐式几何是包含或者说相对关系），可以将具体的值转换为另一组具体的值。

#### 7.1.2.1. 面对象文件

显示几何最经典的使用中，通过很多的点所组成的面来描述物体的表面，而此处必然涉及到用于描述这些物体信息的文件。

（波）面对象文件，Wavefront Object File，通常保存为 `.obj` 文件，其中的内容可能采用以下的格式进行存储：

- **`v` 顶点**<br>保存各个顶点在三维空间中的位置信息，包括其xyz轴坐标
- **`vn` 顶点法线**<br>顶点的法线方向，同样保存的是xyz信息，表示这个法相向量
- **`vt` 贴图坐标**<br>顶点对应的贴图的位置信息，UV坐标中的坐标
- **`f` 对应关系**<br>使用一组映射关系，连接顶点、顶点法线、贴图坐标三个信息，使得能表示完整的一个顶点。同时，将三个完整的点形成一组，表示一个平面。

#### 7.1.2.2. 贝塞尔曲线

贝塞尔曲线是通过一系列的控制点，同时，在每个控制点上可以控制曲率从而影响最终形成的曲线样式。

![几何-显示几何-贝塞尔曲线](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/几何-显示几何-贝塞尔曲线.png)

而为了绘制贝塞尔曲线，可以使用德卡斯特里奥算法（de Casteljau ALgorithm），其推理的过程如下：

1. 确定三个点，此处确定$b_0$、$b_1$、$b_2$三个点，其中$b_0$为曲线的起点，$b_2$为曲线的终点
2. 此时，可以在$b_0b_1$线段上确定任意一个点，这个点将线段切分为两个部分，并确定一个比值$b_0b_0^1:b_0^1b_1$
3. 之后，在$b_1b_2$的相同比例位置处，得到$b_1^1$点
4. 连接$b_0^1b_1^1$，在$b_0^1b_1^1$的相同比例处，确定$b_0^2$
5. 通过不断重复这个过程，最终得到的就是一个完整的贝塞尔曲线（变化这个比例的值，从0一直到1）


通过这样的过程，其实可以进行转换，将其进行计算：

顶点坐标相加，具体理解可以看齐次坐标相关概念

$$
\begin{align*}
b_0^1&=tb_0+(1-t)b_1\\
b_1^1&=tb_1+(1-t)b_2\\
b_0^2&=tb_0^1+(1-t)b_1^1\\&=t^2b_0+2t(1-t)b_1+(1-t)^2b_2
\end{align*}
$$

由此拓展，更高阶的贝塞尔曲线也可以使用类似的方式推理，最终总结为下方的式子

$$\operatorname{B}_{i}^{n}(t)=\operatorname{C}_n^it^i(1-t)^{n-i}$$

> <span style="color:red; font-weight:bold">拓展</span>
>
> 贝塞尔曲线是通过多个点的关系逐步推理出曲线的位置，这个过程并不是一定只能发生在平面内，通过将这个公式拓展到三维空间中，也可以用于实现<span style="border-bottom:2px solid red">贝塞尔曲面</span>。

## 7.2. 曲面更新/转化

在遇到模型原本的曲面不能应对，或者与预期场景不符时，通过某些手段，将其进行转换，使其可以更好地适应特定场景的需求。

### 7.2.1. 曲面细分

对于一个立体的图像，利用具体的点和面来进行描述，通常使用三角形来描述物体的表面，并最终还原成一个完整的物体。通常情况下，面（或三角形）的数量将决定描述的物体质量，为了能够更加还原物体的细节，需要在合适的位置上为其添加更多的面。此时，有涉及到了如何将原本细节不足的物体，逐渐增加其细节，此处就涉及到了**曲面细分**的知识。

#### 7.2.1.1. Loop细分

> 具体介绍，可以查看 [Matt's Webcorner - Subdivision](https://graphics.stanford.edu/~mdfisher/subdivision.html) 个人博客

Loop细分，Loop Subdivision，针对三角形作为图元的场景，通过取三角形各个边的中点，并进行连接，最终将得到的是原三角形进行等比切分之后的4个小三角形。

进行细分之后的通常采用的是**分别处理新老顶点**的方式来处理顶点之间的变换。通过使用Loop细分得到的新顶点，另外存放，与老节点进行区分。在之后的处理中，新老顶点使用完全不同的两套处理逻辑：

- ***新顶点***<br>因为很可能会涉及到三角形与三角形之间共用一个边的情况，因此此处考虑时是直接考虑两个三角形拼接成的菱形。在其中，将利用切分边上的顶点（此处将其定义为近点 $V_n$）和边所对应的顶点（此处定义为远点 $V_f$），通过使用加权平均的方式，得到最终新顶点的值。$$V=\cfrac{3}{8}(V_n^1+V_n^2)+\cfrac{1}{8}(V_f^1+V_f^2)$$
- ***老顶点***<br>因为切分后，引入新的顶点，可能导致老的顶点位置发生变化。将会根据相邻的顶点位置（此处定义为 $V_{neighbor}$），更新老顶点的位置（此处定义为 $V_{original}$），此处一般遵循一个规律：<span style="border-bottom:1px dotted black">如果顶点数量不大于3，则认为这个顶点自身的影响较大，设置权重为$u=\cfrac{3}{16}$；如果大于3，则顶点本身的影响也会随之降低，设置权重为$u=\cfrac{3}{8n}$（其中$n$表示相邻顶点的数量）</span>。$$V=(1-n*u)*V_{original}+u*\sum_{i=0}^{n}V_{neighbor}^i$$

#### 7.2.1.2. Catmull-Clark Subdivision

Catmull-Clark Subdivision 与 Loop Subdivision 相比，可以用于处理四边形的场景，最终的实现方式是尽可能将所有的图元转换的为四边形。

> **概念**
>
> 在 Catmull-Clark Subdivision 之前需要了解的部分概念：
> - **Non-quad face 非四边形面**
> - **Extraordinary vertex 奇异点**<br>度不为4的顶点，就是奇异点（<u>度是表示顶点所连接的边的数量</u>）

Catmull-Clark Subdivision的**使用步骤**如下：

1. 取所有边的中点
2. 取所有面的中点
3. 通过面的中点，连接同一个面内的刚产生的边的中点

在 Catmull-Clark Subdivision 中，具有以下的几个特点：
- 在经过细分之后，会增加非四边形数量的奇异点（面中点），同时可以保证之后不再增加
- 新增的奇异点度数就是原非四边形边的数量（因为会连接各个边）
- 经过一次细分后得到的所有的图元都变为了四边形（奇异点不会再增加的原因）

---

在进行细分之后，对顶点的处理，此处一般准许特定的更新规则（针对四边形面）：

首先，将细分后的顶点分为三类：面中心（$f$）、边中心（$e$）和老顶点（$v$）。

- **面中心**<br>通过所在面的顶点求平均得到。（可能存在三角形的情况，$n$变成3）$$f=\cfrac{\sum\limits_{i=1}^{n}v_i}{n}\Rightarrow\cfrac{v_1+v_2+v_3+v_4}{4}$$
- **边中心**<br>通过边上的两个顶点以及两个相邻面的中点平均得到。$$e=\cfrac{v_1+v_2+f_1+f_2}{4}$$
- **老顶点**<br>老顶点则是由面中点和边中点重新进行计算。$$v=\cfrac{\sum\limits_{i=1}^{n}f_i+2\sum\limits_{i=1}^{n}e_i+nv_{original}}{4n}$$

### 7.2.2. 曲面简化

在某些场景中，可能会涉及到模型过于复杂，希望可以通过简化模型面的方式，来提升性能。

在大部分使用，当物体距离屏幕较远时，我们通常希望它的细节可以在一定程度上下降，从而达到提升性能的效果。更进一步，我们希望实现的效果是，随着距离的上升，可以实现很自然的面数下降，同时保证物体的形状不会发生特别明显的变化。

#### 7.2.2.1. 边坍缩

边坍缩，Collapsing An Edge，逐步减少某条边的长度，直到两个端点重合，实现边坍缩。

<span style="color:red; font-weight:bold">难点：如何确定模型中，那条边算是比较不太重要的边来进行坍缩？</span>

此处可以利用<span style="color:red; font-weight:bold">[二次误差度量](#title-%E4%BA%8C%E6%AC%A1%E5%BA%A6%E9%87%8F%E8%AF%AF%E5%B7%AE)</span>技术。

对模型的每一条边都进行测试，并得到其对应的二次度量误差，误差值越小，就越先进行边坍缩，按照这样的顺序进行坍缩，距离较近时就算有曲面简化，也不会非常明显，能够在节省资源的同时，保证表述的物体并没有发生改变。

此处还需要注意，事实的场景中，可能会出现因为某条边坍缩之后，导致其他的边坍缩所带来的二次度量误差变化，因此在计算其顺序时，采取贪心算法（不考虑全局最优），一般使用堆或者优先队列。

<a id="title-%E4%BA%8C%E6%AC%A1%E5%BA%A6%E9%87%8F%E8%AF%AF%E5%B7%AE"></a>

##### 7.2.2.1.1. 二次误差度量

![曲面简化-二次误差度量](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/曲面简化-二次误差度量.png)

如果是针对左侧一条折线，希望将中间的三个点进行合并，最终依然想表示原本的折线，而不会产生太大的误差。如果是使用平均的方式，不管是考虑全部的5个端点，还是收缩的3个顶点，都会导致折线包围的面积明显变小，与原本的内容有一定的区别。而使用二次误差度量，就是计算出一个端点位置，使得它到原本的线段的距离之和尽可能小，从而降低面积的误差。

而此处的得到的面积与原本的面积之间的差值，就称为**二次度量误差**，得到这个误差的过程，就是二次误差度量。

## 7.3. 补充内容

- 样条

    一条可控的曲线叫做样条（Splines），可以通过显示几何来描述这种变化的过程，从而得到其中任意一个位置的值。

    **B-Splines**，B样条（某种曲线）具有以下的特性：

    - 是样条基础的缩写
    - 需要比贝塞尔曲线更多的信息（Require more information than Bezier curves）
    - 满足贝塞尔曲线所具有的所有重要属性（即超集）<br>如希望可以确定曲线的整体之后，能够只对其中的部分进行修改，而其余部分不发生改变

    > [B样条学习](https://www.bilibili.com/video/av66548502?from=search&seid=65256805876131485)

# 8. 光线追踪

光线追踪，Ray Tracing，是为了来解决在光栅化过程中所出现的很多问题而出现的一种技术，如不能很好的处理全局的问题，导致包括软阴影在内的很多成像并不真实。

相对的，光线追踪的目标是更加真实的图像，相对的，导致其很难实现实时的画面，大多数情况运用于离线场景，如动画电影的渲染，通过大量时间进行渲染，最终形成最终的成片。

首先，基于现实的性质，在图形学中认为，光线具有以下三个性质：

1. 光线经过直线传播<br>如果是现实物理学中可能并不严禁，但在宏观角度上，基本上可以认为是直线传播。同时图形学中的光，一般情况下会忽略它的波动性。
2. 光线在交叉的时候并不会发生碰撞<br>光线与光线直接不会互相影响。
3. 光线传播可逆<br>光线传播时，是从光源经过多次的碰撞，最终到达人眼/摄像头，为了更好得推理整个过程，减去不必要的内容（此处指的是不可能进入观测点的光线处理），反向进行推理。

> <span style="color:red;font-weight:bold">定义</span>
>
> - **eye ray** 视线<br>从观测点发出的射线，用于追踪光线传播的过程
> - **primary ray**<br>视线还没有发生过碰撞的状态
> - **secondary ray**<br>视线在交点处进行后的后续传播过程，都被统称为 secondary ray
> - **shadow ray**<br>交点与光源之间的连线

## 8.1. 基础实现

光线追踪，基本的实现思路一般如下：

1. 假设，在观测点之前有一个被换分为很多个小正方形的面，此处对应最终成像的各个像素。通过连接观测点与平面内的任意一个像素，就形成了视线（eye ray）。
2. 延长视线，其最先碰到的物体，在其表面留下一个交点。
3. 尝试将交点与光源进行连线，如果能够连通，说明光能够找到这个位置，反之则不能，计算该点的颜色，并颜色将存放在这个像素中。

### 8.1.1. Whitted-Style Ray Tracing

递归光线追踪，Recursive (Whitted-Style) Ray Tracing，在基础实现之上，让实现在交点处，根据其表面的物理性质，经过如反射、折射等变换之后，继续传播，并打在更多的面上，不断重复这个过程，最终使用多个交点的值，来共同决定像素的值。

## 8.2. 射线交点

计算射线之前，首先定义射线。其起点指定为 $o$，方向指定为 $d$，可以使用下方的式子来表示这条射线：$$\begin{array}{c}r(t)=o+t\vec{d}&0\leq t\leq\infin\end{array}$$

通过中学的知识，求解交点就是找到同时在两个物体上的点，为了找到这个点，可以通过联立方程的方式，进行求解。

### 8.2.1. 隐式表面交点

其中，对所求得的结果，要求必须是正实数。如果结果是实数，说明两个物体之间才存在交点，反之，说明没有交点。因为光线是射线，得到的结果是负数的场景并没有意义。因此，通过这样的理论进行推导，现在已经可以直接将**隐式表面**（使用隐式几何表示的表面）和射线函数联立求解，就可以得到它们的焦点。

### 8.2.2. 显示表面交点

隐式表面交点的基础上，**显示表面**（使用显示几何表示的表面），则通常将被转换为与三角形之间求焦点。

首先得到三角形所在的平面，其中已知一个平面上的点 $p'$，以及平面的法线 $\vec{N}$，最后使用 $p$ 表示平面内的任意一个点。可以平面将表示为：
$$
\begin{align*}
&\begin{cases}(p-p')\cdot \vec{N}=0\Rightarrow ax+by+cz+d=0\\r(t)=o+t\vec{d}\end{cases}\\&\Rightarrow\begin{array}{c}t=\cfrac{(p'-o)\cdot \vec{N}}{\vec{d}\cdot \vec{N}}&0\leq t\leq \infin\end{array}
\end{align*}
$$

之后，通过交点，使用三角形的插值法进行计算来判断平面上的交点是否在三角形内。

---

<u>在基础的实现之上</u>，人们发现了一种更加直接的算法，能够直接通过三角形的顶点位置与所在平面建立关系，之后联立方程，最后求解方程组就能跳过求平面交点的过程。

通过三角形的插值算法可知，在三角形内部的点，可以使用三角形的三个顶点坐标来表示。同时，三个关系值之和为1时，可以表示在三角形的平面内存在交点，同时这个三个关系值都不唯一，则说明交点在三角形内部。

#### 8.2.2.1. 包围盒

如果需要判断光线将会经过哪些物体，就需要不断使用物体表面的三角形与光线进行交点计算，这样的计算量将会非常巨大。

通过使用包围盒的技术，可以显著降低在这个过程中的性能损耗。目前比较常见的包围盒技术，是轴对齐包围盒，Axis-Aligned Bounding Box，AABB，通过分别取物体x、y、z轴最大和最小值，就可以形成两个点来形成一个包围盒（包围盒的边分别x、y、z轴方向拜访，不会倾斜）。

首先判断光线与包围盒是否存在交点，如果不存在交点，可以直接判定光线与物体之间没有交点。

<span style="color:red; font-weight: bold">如何判断光线与包围盒相较？如何得到光线在包围盒的范围？</span>

通过对包围盒的三个相对平面分别对光线求交点，之后，可以通过对三组向对面交点求**交集**，得到光线在包围盒内的范围。

在这个基础上，需要关注以下的问题：
- 光线只会向光线的正方向衍生，因此需要忽略光线起点之后的所有包围盒。
- 光线的起点如果为负，说明光线的起点在包围盒内，光线与包围盒肯定存在一个交点。

使用包围盒后，省去了对未相较的包围盒内的物体表面大量的求交点操作。此处依然存在问题，包围盒内部的物体与包围盒内部的光线进行求交。

##### 8.2.2.1.1. 空间划分

其实可以使用同样的方法（进一步划分包围盒），将包围盒内也划分为很多个更小的空间，减小检测光线与三角形比较的次数，实现加速的效果。

使用多层包围盒需要注意，其中需要关注的主要有两个问题：

1. 如何在内部进行划分才能提高效率？<br>虽然对包围盒内部进一步细分可有提高效率，但也不是随便划分都可以提升效率，划分的数量不能太多，也不能太少，否则优化的效果都会有所减低。
2. 分块与分块之间的光线如何追踪？<br>在分块中，光线必然会向相邻的一个分块移动，因此也可以随着光线依次传递并追踪光线的状态

<span style="color:red; font-weight:bold">KD-Tree</span>，对各个平面交替进行水平、竖直切分，最终保证切分的图案比较方正的一种空间划分方案。

为了能够更好的保存KD-Tree产生的数据，将使用二叉树，将其最终得到的图案信息保存到各个叶子节点上。

![包围盒-空间划分-KD-Tree](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/包围盒-空间划分-KD-Tree.png)

> 同类的处理方式还有：Oct-Tree、BSP-Tree等一系列对空间的划分

##### 8.2.2.1.2. 物体划分

绑定体积的边缘划分（或边界体积层次结构），Bounding Volume Hierarchy，BVH。与之前的通过划分空间，得到不同区域的物体不同，它通过对不同的物体进行分组划分，将其框选在不同的空间范围内。

![包围盒-空间划分-构建BVH](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/包围盒-空间划分-构建BVH.png)

通常情况下，按照以下的步骤进行确定BVH：

1. 确定需要进行划分的包围盒
2. 将所有的物体划分为两个部分
3. 重新计算两个部分的物体的包围盒
4. 重复步骤2，直到包围盒内的物体足够少

> 技巧：
>
> - 优先选择对最长的边进行切分（尽可能让最终划分出的空间接近正方形）
> - 关注划分的两个部分的物体数量时，可以直接选择从中位数处进行划分（尽可能保证划分出两个部分的物体或者三角形数量接近，有利于之后的计算）

# 9. 辐射度量学

在之前的Blinn-Phong光照模型中，最终得到的也只是表面近似的光照效果，为了能够得到更加真实的光照模型，就需要使用到**辐射度量学**。

它对辐射度量学为光照定义了很多属性（目前没有比较合适的翻译，中文供参考）：
- Radiant flux 辐射通量
- intensity 强度
- irradiance 辐照度
- radiance 光泽度

## 9.1. 概要

对辐射度量学的学习之前，首先需要了解所定义的属性代表的意义。

### 9.1.1. Radiant Energy and Flux(Power)

- Radiant Energy 指的是光照中包含的能量，单位为 $J=Joule$
- Radiant Flux 为了与 Radiant Energy 做出区分，通常将其记做 Power（类似功率），单位为 $\begin{array}{c}W=Watt&lm=lumen\end{array}$，表示为每秒的能量 $\Phi\equiv\cfrac{dQ}{dt}$

### 9.1.2. Radiant Intensity

Intensity 定义了光在每个单位立体角（solid angle）上的 power，表示为 $I(\omega)=\cfrac{d\Phi}{d\omega}$，单位则使用 $\cfrac{W}{sr}$ 或者 $\cfrac{lm}{sr}=cd=candela$ 来表示

> <span style="color:red; font-weight:bold">立体角</span><br>对任意一个圆形（定义半径为 $r$），从圆心任意选择一个角度，这个角度将从圆上截取一段弧线（定义为 $l$），此时可以得到一个关系 $\theta=\cfrac{l}{r}$，同时，圆形不管是发生了放大还是缩小，都可以保证最终的这个比值不变。<br>将这个特性扩展到三维，对于一个球（半径 $r$），选择一个角度，将形成一个圆锥，并最终框出球面上一个范围（面积 $A$），可以使用 $\color{red}{\Omega}\color{black}{=\cfrac{A}{r^2}}$ 来得到角度值。而这样的比值（$\Omega$），就被定义为立体角。<br>这个立体角所对应的面积，通常希望定义一个单位面积，大致的算法将单位面积表示为：$d_A=(rd\theta)(rsin\theta d\phi)=r^2sin\theta d\theta d\phi$。

立体角用于更好的表述光照的强度，最终表示的将是某个方向上光照的强度。通过其定义进行拓展，与 Radiant Flux 建立联系。

Radiant Flux 表示的是某个半径下，整个球面位置处的光照强度，而 Radiant Intensity 表示的是某条边上的光照强度（将其球面划分得到对应的单位平面）。计算表示的对应关系如下：

$$
\Phi=\int_{S^2}Id\omega=4\pi I\qquad (I=\cfrac{\Phi}{4\pi})
$$

### 9.1.3. Irradiance

Irradiance 定义为单位面积上的 Radiance Flux（Power），表示为 $E(x)=\cfrac{d\phi(x)}{dA}$，单位使用 $\cfrac{W}{m^2}$ 或者 $\cfrac{lm}{m^2}=lux$。

<span style="text-decoration: wavy underline">其中，必须是对应垂直方向上的 Power 或面积。</span>

使用 Irradinance 来描述点光源随着距离提高而导致能量降低的过程，其表示的是单位面积上的能量，以半径为 $r$ 的球面为例，其单位面积上的能量为 $E=\cfrac{d\phi}{4\pi r^2}$，半径将引起能量的平方倍变化。

此处需要与 Intensity 做出区别，Intensity 表示的是立体角，而立体角随着半径的变化并不会发生改变，只会导致对应的球面积增大，并没有得到直接的能量关系。Irradiance 能够更好的表示同一个面积下，能量随着距离变化的过程。

### 9.1.4. Radiance

Radiance 定义为单位平面上对周围辐射的单位立体角的能量。Radiance 是在 Intensity 和 Irradiance 基础上，进行了一定的整合，用于光到达某个平面后，其单位面积能够向周围辐射出的单位立体角的能量。（可以理解为计算光照到达某个平面后，能够继续传播的强度）

表示为 $L(p, \omega)\equiv\cfrac{d^2\phi(p,\omega)}{d\omega dAcos\theta}$（其中 $\theta$ 表示为立体角与平面法线的夹角），单位使用 $\cfrac{W}{srm^2}$ 或 $\cfrac{cd}{m^2}=\cfrac{lm}{srm^2}=nit$。

> **定义对比**
> - Radiance 单位平面上对周围辐射的单位立体角的能量
> - Irradiance 单位面积内包含的能量
> - Intensity 单位立体角的能量
>
> 通过对比，可以了解到 Radiance 大致可以表示为：
> - 单位立体角的 Irradiance
> - 单位面积能够得到的 Intensity
>
> Irradiance（表示为 $E$） 和 Radiance（表示为 $L$） 之间的等式：
> $$\begin{align*}dE(p, \omega)&=L_i(p, \omega)cos\theta d\omega\\E(p)&=\int_{H^2}L_i(p,\omega)cos\theta d\omega\end{align*}$$此处的 $H^2$ 表示点代表的单位面积，所能接受到的光（或者说是有效的立体角）

Radiance 因为它的定义，可以很好的表示光线在不同传播状态的效果，如入射光以及出射光的不同。

#### 9.1.4.1. Incident Radiance

Incident Radiance，入射光，从某个角度照射到平面的光，其传入的能量大小。（类似 Irradiance）
$$
L(p, \omega)=\cfrac{dE(p)}{d\omega cos\theta}
$$

#### 9.1.4.2. Exiting Radiance

Exiting Radiance，出射光，从平面能向某个方向辐射出的能量。（类似 Intensity）
$$
L(p, \omega)=\cfrac{dI(p, \omega)}{dAcos\theta}
$$

## 9.2. BRDF

BRDF，Bidirectional Reflectance Distribution Function，在辐射度量学中，用于描述反射的过程。

在辐射度量学中，将光线反射的过程理解为：从某个方向上入射的光照射在平面上，平面将这部分能量吸收，再向各个方向辐射出新的光。而这个过程中，将利用不同的比例，来控制反射出的光线在不同方向上的效果。

使用 $f_r$ 来表示某一个单位立体角的出射光，其中将会涉及到入射光方向 $\omega_i$、出射光方向 $\omega_r$、入射光能量（使用 Irradiance 表示）$E_i$、出射光在某一单位立体角内的能量（使用 Radiance 表示）$L_r$。最终的关系如下：

$$
f_r(\omega_i\rightarrow\omega_r)=\cfrac{dL_r(\omega_r)}{dE_i(\omega_i)cos\theta_id\omega_i}\left[\cfrac{1}{sr}\right]
$$

通过上方的式子，得到了一条入射光，在某个位置处，向某个单位立体角所得到的光照强度，在这个基础上，对 $f_r$ 进行积分，结合所有在同一个位置上的所有入射光，最终得到的就是最终的出射光。

$$
L_r(p, \omega_r)=\int_{H^2}f_r(p, \omega_i\rightarrow\omega_r)L_i(p,\omega_i)cos\theta_id\omega_i
$$

> - $H^2$ 表示有效立体角的面积（通常直接理解为半球）
> - $p$ 代表指定的点或者点附近的单位面积

## 9.3. 渲染

在辐射度量学中，根据 BRDF 中分析的反射过程中得到的出射光，如果物体本身能够发光的情况，只需要在计算反射光后，在叠加上物体本身发出的光照即可。最终的渲染方程如下：

$$
L_o(p,\omega_o)=L_e(p,\omega_o)+\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot\omega_i)d\omega_i
$$

对于真实的渲染来说，可能存在大量光源向目标位置发射能量，而光源照射到的面，经过反射，也会将能量发射给观测的面。

而这其中，甚至可能出现自身反射光照并叠加的状态。

为了简化光照渲染的模型，可以从以下几个细节出发：
- 转换大面积入射光，从很多个位置发射来的光，转换为某个立体角对应的 Radiance，最终只需要 Radiance 乘上平面大小，从而简化部分光照模型
- 区分光源以及反射面，分别处理光源和反射面，将原本分别计算所有需要反射的场景，转换到某个特殊的反射参数

### 9.3.1. 转换方程

通过 BRDF 得到，最终的函数为：
$$
l(u) = e(u) + \int l(v)\underbrace{K(u,v)dv}_{\text{kernel of equation}}
$$

其中，方程的核心 $K(u,v)dv$，用于表示光照的转换方程。通过对方程进行简化（转换），可以得到以下的结果：

$$
\begin{align*}L&=E+KL\\IL-KL&=E\\(I-K)L&=E\\L&=(I-K)^{-1}E\\\text{Binomial}&\text{ Theorem}\\L&=(I+K+K^2+K^3+\dots)E\\L&=E+KE+K^2E+K^3E+\dots\end{align*}
$$

> 注意，其中使用的是 $I$ 表示单位矩阵，而不是 $1$。

最终得到的式子，其表示的就是光分别通过不同的反射次数所得到的值，如 $E$ 表示光源直接照射的光，$KE$ 表示反射一次，$K^2E$表示反射两次，以此类推。

# 10. 路径追踪

在之前的 Whitted-Style Ray Tracing 中，虽然能够追踪光线的变化，并最终形成观察的图像，但是其中依然存在一定的问题。如，视线到达的地方，虽然不存在直接的光照，但是却存在其他的间接光照，而 Whitted-Style Ray Tracing 模型在判断光源无法到达的地方就直接停止向下迭代。因此，这样的成像并不真实。

![路径追踪-直接光照与全局光照](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/路径追踪-直接光照与全局光照.png)

> Whitted-Style Ray Tracing 就类似此处的直接光照模型（direct illumination），而真实的场景中，存在大量的漫反射，使得某些位置虽然不能直接接收到光照，但是也可能间接得被另一个位置反射出的光照亮。<br>同时，其中还存在一种现象，虽然物体本身是棕色（中间左侧的高柱子），然而其左面却显示为红色，这就是因为光线通过墙面反射到平面上，这个现象也被称为 Bleed（颜色渗开）。

路径追踪，Path Tracing，就是为了提高最终成像的效果，追求更加真实的光照效果。<span style="color:red; font-weight: bold">姑且也算是 Ray Tracing 中的一个部分。</span>

## 10.1. 概要

在正式开始路径追踪之前，必须了解的部分知识。

### 10.1.1. 镜面反射材质

对于目前涉及到的材质，部分材质虽然可以反射

- specular 镜面材质<br>材质的表面发生完全镜面反射。
- glossy 光滑材质<br>虽然能够发生镜面反射现象，但是成像并不清晰，最终反射得到的图像比较模糊。

### 10.1.2. Monte Carlo Estimator

蒙特卡罗（洛）积分，是一种定积分的处理方式，与黎曼积分的处理方式本质上类似，但是借助了概率论的知识。通过在范围内随机取点，并以所得到的值以及其分布概率，得到期望值。为了减小误差，将多次使用多次求平均的方式。其表示为：

$$
F_N=\cfrac{1}{N}\sum_{i=1}^N\cfrac{f(X_i)}{p(X_i)}
$$

![拓展-蒙特卡洛积分](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/拓展-蒙特卡罗积分.png)

首先，通过积分的定义，其表示的是函数曲线与x轴之间形成的面积之和（x轴上为正，x轴下为负），可以描述为 $X_i\sim p(x)=C$。定积分 $X_i\sim p$ 以及其对应的面积为 $C$。对这样的积分式子进行推导，可以得到以下的关系。

$$
\begin{align*}&\int_a^bp(x)dx=1\\\Longrightarrow&\int_a^bCdx=1\\\end{align*}
$$

**如果，其中的各个 $p(x)$ 都直接取相同的值，即最终采用平均采样的方式**，可以得到最终的值：$C=\cfrac{1}{b-a}$

将最终的结论 $X_i\sim p(x)=C=\cfrac{1}{b-a}$ 带入蒙特卡洛积分：

$$
F_N=\cfrac{b-a}{N}\sum_{i=1}^Nf(X_i)
$$

### 10.1.3. 俄罗斯轮盘赌

在追踪光线传播的过程中，使用迭代，不断判断利用下一次交点的能量，并继续向后逆推能量传播的过程。

为了让光线能够在一个更加合适的时机停止迭代（而不是选择某个固定的弹射次数）。

俄罗斯轮盘赌，Russian Roulette，RR，每次反射，假定其有 $P$ 的概率继续传播，相对的有 $1-P$ 的概率停止。最终得到的能量可以表示为：$E=P*(L_o/P)+(1-P)0$。而这个式子，最终的数学期望依然是 $P$。

## 10.2. 优化

利用之前 Whitted-Style Ray Tracing 以及辐射度量学的知识，理论上已经可以还原出一个比较真实的光照场景了，然而，这其中还存在很多问题需要解决。

### 10.2.1. 反射优化

通过辐射度量学中的知识，如果想要得到某个点上，对应的真实光照效果，需要对该点对应的所有可能存在入射光的角度进行反向推演，通常的处理，是对半球面生成很多的采样点，多各个采样点进行迭代。

而这样的推导，也使得每次反射都会反推出大量的结果，并使得计算量呈现出指数型变化。

为了解决这个问题，将思路进行转换，每次反射不再使用大量的采样点，而是依然只会反射出一条光线，这样的变化，1的指数变化最终依然会是1。

> 拓展：<br>重要性采样，在蒙特卡洛积分中，对概率的取值并不一定平均（不一定平均采样），可以通过某些权重，来使得选择的光线更加有效。

### 10.2.2. 优化光源采样

> 主要针对的是反射优化后，随之出现的采样不足，或者无效值过多，导致出现大量的斑点（黑块）的问题

在路径追踪的处理中，其关注的通常是各个光的反射点本身，而在这样的情况下，由于反射采样的降低，使得从反射点追踪很多时候得到的都是无效的路线（最后没有通向有效的光源），导致呈现出黑色。

![路径追踪-优化-优化采样过少](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/路径追踪-优化-优化采样过少.png)

为了减小这种情况，将各个反射点非为两种情况：
- 光源光照
- 间接光照

间接光照就是原本处理的逻辑，不需要发生改变，而在这个基础上，增加光源光照。即，对每个点，假定其能够接收到来自光源的光照，并将其叠加到现在的数据上。

> 在辐射度量学中，对于点光源的处理比较困难，通常将其转换为较小的面光源

<span style="color:red;font-weight:bold">如何获取来自光源的能量？</span>

- **思路一**<br>利用辐射度量学中的知识，计算光源各个采样点将会传递给反射点
- **思路二**<br>直接将光源的面积，投影到垂直入射方向的平面上，利用 Radiance 进行计算

利用上方思路二的逻辑，可以直接将能量计算的式子转换为以下的结果：

$$
\begin{align*}L_o(x,\omega_o)&=\int_{\Omega+}L_i(x,\omega_i)f_r(x,\omega_i,\omega_o)cos\theta d\omega_i\\&=\int_AL_i(x,\omega_i)f_r(x,\omega_i,\omega_o)\cfrac{cos\theta cos\theta'}{||x'-x||^2}dA\end{align*}
$$

通过这样的转换，还可以将原本在光源上进行的蒙特卡洛积分，转换到了反射点上

> 蒙特卡洛积分中要求，只能对概率函数对应的轴进行积分，如此处，因为只有光源上的取值概率，就不能直接使用反射点上的采样点概率，因此必须要进行转换，将最终的积分变量转换为光源上的面积

# 11. 材质和外观

现实中，物体呈现不同的外观或材质，是因为其对光照的处理使得其表面呈现出完全不同的效果。

在图形学中，利用辐射度量学的知识，想要实现不同的材质，就需要从反射 BRDF 下手，使不同位置的反射，呈现出不同的材质效果。

## 11.1. 光的传播

材质的区别主要体现在光线的传播中，此处是在 BRDF 的理论下，来重新对光线的传播进行分析。

### 11.1.1. 漫反射

在 BRDF 中体现的漫反射，就是在面上的能量，会自动向周围进行辐射，此处的能量与方向之间依然满足能量吸收时的，需要对能量进行映射，因此越垂直的方向反射出的 Radiance 越少。

此时，假定，某个物体，只会发生漫反射，同时它在反射光的过程中，能量没有损失（物体不会吸收光），那么入射光与反射出的漫反射光总量将相等。

$$
\begin{align*}L_o(\omega_o)&=\int_{H^2}f_rL_i(\omega_i)cos\theta_id\omega_i\\&=f_rL_i\int_{H^2}\cancel{(\omega_i)}cos\theta_id\omega_i\\&=\pi f_rL_i\end{align*}
$$

> 其中，对半球的 $cos$ 求积分，得到的值是 $\pi$

通过上方的式子，因为入射的 $L_i$ 能量与出射的 $L_o$ 应该相等，因此最终的漫反射系数将被描述为：$f_r=\cfrac{\rho}{\pi}$。因此，如果 $\rho=1$，说明这个平面只会发生漫反射，同时反射的过程不会损失能量。

通过操作反射系数中的 $\rho$，就能修改物体表面的漫反射效果。通常，使用颜色的值来作为 $\rho$，使其在表示漫反射强度的同时，还可以携带颜色的信息，同时满足白色就会反射所有光的常识。

### 11.1.2. 镜面反射

镜面反射向量计算，利用入射光和出射光与法相之间的夹角相同，通过两者做平行四边形，最终得到的向量和将与法相方向相同，并且其长度是 $\omega_i\cdot cos\theta=\omega_i\cdot\vec{n}$。

$$\begin{align*}&\omega_i+\omega_o=2cos\vec{n}=2(\omega_i\cdot\vec{n})\vec{n}\\&\omega_o=-\omega_i+2(\omega_i\cdot\vec{n})\vec{n}\end{align*}\\$$

### 11.1.3. 折射

> 实际上 BRDF 中，并不包含折射的内容，通常将折射与 BRDF 的内容统称为 BSDF（双向散射分布函数）

光线在不同介质之间传播时，因为其不同的折射率，导致原本倾斜的光线在进入另一个材质后不再沿着原本的方向传播。折射的过程可逆，通过两个材质不同的折射率，可以保证两者的 $\eta sin\theta$ 值相等，同时两者的方向角依然相等。（投影后相对）

> **方向角**<br>将两个向量，投影到交点平面上，所形成的角度（可以理解为从法线上方进行观察的结果）。

计算折射角的余弦：

$$\begin{align*}\eta_i sin\theta_i&=\eta_t sin\theta_t\\cos\theta_t&=\sqrt{1-sin^2\theta_t}\\&=\sqrt{1-\left(\cfrac{\eta_i}{\eta_t}\right)^2sin^2\theta_i}\\&=\sqrt{1-\left(\cfrac{\eta_i}{\eta_t}\right)^2\left(1-cos^2\theta_i\right)}\end{align*}$$

通过上方得到的结果，发现其中存在实数中没有意义的结果，也就是不会发生折射的情况：$1-\left(\cfrac{\eta_i}{\eta_t}\right)^2(1-cos^2\theta_i)<1$。可以得到，<span style="color:white; background-color:DimGray">当 $\eta_i>\eta_t$，也就是入射光所在材质的折射率大于出射光所在材质时，有可能出现没有折射的现象，被称为<span style="color:OrangeRed;font-weight:bold">全反射</span>。</span>

#### 11.1.3.1. 菲涅尔反射/菲涅尔项

![材质-折射-菲涅尔反射](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/材质-折射-菲涅尔反射.png)

菲涅尔反射描述的是，随着观察的方向与物体之间的角度变化，导致得到的效果也发生变化的现象。如上图中，随着视角逐渐与桌面平行，发生的反射效果明显更强，反射更加清晰。（与光源的方向也有一定的关系）

这是因为随着观察方向与物体的法线防线逐渐垂直，折射的比率会逐步降低，直到最终变为全反射。

菲涅尔项就被用于计算，光到达某个交点后，有多少能量将被用于反射。

菲涅尔反射方程，需要首先计算光的两个极化（指的是光波的横波与纵波的情况，通常应用中取其平均值）：

$$
\begin{align*}R_s&=\left|\cfrac{\eta_icos\theta_i-\eta_tcos\theta_t}{\eta_icos\theta_i+\eta_tcos\theta_t}\right|^2=\left|\cfrac{\eta_icos\theta_i-\eta_t\sqrt{1-\left(\cfrac{\eta_i}{\eta_t}sin\theta_i\right)^2}}{\eta_icos\theta_i+\eta_t\sqrt{1-\left(\cfrac{\eta_i}{\eta_t}sin\theta_i\right)^2}}\right|^2\\R_p&=\left|^2\cfrac{\eta_icos\theta_t-\eta_tcos\theta_i}{\eta_icos\theta_t+\eta_tcos\theta_i}\right|=\left|\cfrac{\eta_i\sqrt{1-\left(\cfrac{\eta_i}{\eta_t}sin\theta_i\right)^2}-\eta_tcos\theta_i}{\eta_i\sqrt{1-\left(\cfrac{\eta_i}{\eta_t}sin\theta_i\right)^2}+\eta_tcos\theta_i}\right|^2\\R_{eff}&=\cfrac{1}{2}(R_s+R_p)\end{align*}
$$

对其进行简化（Schlick's approximation），得到了以下的式子：

$$
\begin{align*}R(\theta)&=R_0+(1+R_0)(1-cos\theta)^5\\R_0&=\left(\cfrac{\eta_i-\eta_t}{\eta_i+\eta_t}\right)^2\end{align*}
$$

其中，假设在 $90'$ 的角时，反射的占比为1，而最开始的反射占比将由两个介质的折射率共同决定，为 $R_0$，大致近似出这条曲线。

## 11.2. 微表面模型

微表面模型，Microfacet Material，在其中定义，物体的表面在微观中实际上是很多并不光滑的突起，但是在宏观上将其理解为一个完整的平面，但是微观中的表面不光滑也将导致光的反射呈现不同的效果。

在微表面模型中，将物体微观表面上的法线划分出其分布的一个范围，根据其分散的幅度，将会决定最终材质的效果。之前的光滑表面 glossy，就是法线偏移不明显，相对集中的材质，光线的大部分都能够到达原本假象光滑平面的反射方向；而粗糙平面 diffuse，法线偏移明显，大部分的光经过反射后，都不能到达预期的反射方向。

最终的微表面模型将会结合以下几个方面的因素，得到最终的结果：
- 菲涅尔反射 $F(i,h)$
- [半程向量](#%E5%8D%8A%E7%A8%8B%E5%90%91%E9%87%8F) $G(i,o,h)$
- 自身阴影遮挡 $D(h)$

$$ f(i, o)=\cfrac{F(i,h)G(i,o,h)D(h)}{4(n,i)(n,o)} $$

### 11.2.1. 各向异性微表面模型

在基础的微表面模型中，假定光线的方向不会影响同一点上反射的效果，这样的模型被称为各项同性微表面模型。

在现实生活中，存在很多人造材质，因为生产的过程中，存在方向的打磨痕迹，使得光线在不同方向上的表现并不相同。比较正式的描述为：在同一个位置上，改变光的水平角，光的表现不同。

# 12. 高级光线传播

光线传播的进阶，以及其对于材质的影响。

## 12.1. 分类

对之前的光线传播进行分类，主要可以分为以下几类：

- 无偏差光线传播 Unbiased light transport methods：
  - Bidirectional path tracing (BDPT)
  - Metropolis light transport (MLT)
- 有偏差光线传播 Biased light transport
  - Photon mapping
  - Vertex connection and merging (VCM)
- 即时辐射度 Instant radiosity (VPL/many light methods)

> 无偏差，如对蒙特卡洛积分，最终得到的结果数学期望与原本的值一致；相对的，如果使用的值的数学期望与原本有区别，就是有偏差。

### 12.1.1. Bidirectional Path Tracing

双向路径最终，分别从光源和观察点进行子路径追踪。实现困难，主要适用于很好确定光源的光照路线的情况，如没有直接照射的聚光灯，主要指的是聚光灯不会照射到观察点，而通过大量的反射光来照亮整个场景。这样的情况适合使用双向路径追踪。

### 12.1.2. Metropolis Light Transport

Metropolis光线传播，利用统计学中的 Markov Chain Monte Carlo，马尔科夫链，通过一个样本，为其添加扰动，生成类似样本。

适用于较复杂的场景，在样本数较少的情况下也能得到比较还原的结果。相对的，其很难确定具体的取样收敛速度，各个像素的收敛速度不统一，导致最终得到的图像噪点较多。

### 12.1.3. Photon Mapping

光子映射，Photon Mapping，实现方式不唯一。其中一种实现方式如下：

1. 从光源起，向周围发射一定量的光子，并在接触到 diffuse 的表面时停止
2. 视线与某个面的焦点，划定一个范围，取周围的光子数量，并求出光子数量与面积之间的比例

比较适用于处理大量的 caustics 图像（复杂的光线传播、聚集、叠加，最终形成明亮的焦点等情况）

但是因为将本来应该连续的数据进行了离散（将其视作很多光子），使得最终的图像将失去很多细节。如果光子足够多，最终的值将越接近真实值。

### 12.1.4. Vertex Connection And Merging

VCM，本质上是双向路径追踪和光子映射的结合，在双向路径追踪的过程中，如果两个点在同一个平面上，并足够接近，就使用光子映射进行处理。

### 12.1.5. Instant Radiosity

实时辐射度，Instant Radiosity，将光源已经照亮的面直接转换为光源。

运算比较迅速，但是在物体的间隙处可能出现高光，同时并不适用于 glossy 物体。

# 13. 高级外观建模

主要包括：

- 非表面模型<br>散射介质、毛发、沙粒
- 表面模型<br>半透明材质、布料、高精度模型
- 程序生成材质

## 13.1. 非表面材质

此处主要包括，如云、雾等，材质并不只是在其表面，而是包含在物体的内部。

> <span style="color:red">甚至很多的固体材质依然可以视作散射介质</span>，如手指尝试挡住闪光灯的光，但最终依然可以透过手指发出一定的光，光的穿透力很强。

### 13.1.1. 散射介质

光线在物体内部传播的过程中，将被随机进行各种如下变化：

![高级模型-散射介质](https://cdn.jsdelivr.net/gh/TMSxH2O/tms_img/notepad/现代计算机图形学入门/高级模型-散射介质.png)

光在经过各个内部的作用点时，将会如何进行散射，将使用 Phase Function（相位函数）来进行描述。

### 13.1.2. 毛发

在处理头发这种材质时，将其简化为圆柱，考虑各个圆柱的反射，并得到以下的模型：

- Kajiya-Kay Model<br>将头发的模型转换为圆柱，光线到达发丝之后，通过圆柱的反射，变为圆锥向外传播。最终成像不太真实。
- Marschner Model<br>在Kajiya-Kay模型上（第一次的反射被简称为 R），额外考虑的光线进入发丝发生折射并传播头发，这将形成第二个圆锥型的发散（被简称为 TT）；折射后的光，到达另一侧后，又会进行一次反射，并重新到达入射的一侧，这将再形成第三个圆锥（被简称为 TRT）。可以得到十分真实的模型。
- Double Cylinder Model<br>双层圆柱模型，基于真实生物学出发，生物的毛发将被分为三层结构，因此需要引入额外的发散过程（毛发中心的圆柱能够将光线尽可能扩散）。在Marschner模型上，分别添加 TTs 以及 TRTs，用于表示这两次内部反射经过了中心材质后，所发生的散射。通过修改不同的比例，可以实现模型不同毛发的效果。

### 13.1.3. 颗粒材质

主要包括如大量细碎砂石堆成的物体等，因为需要考虑在大量微小物体之间的反射，因此制作困难。

## 13.2. 表面材质

材质覆盖在物体表面，但是此处主要描述的是光线能够穿透材质，因此同样需要考虑光在物体内部的繁杂变化。

### 13.2.1. 透光材质

主要与玻璃材质做出区分，其内部同样有很多颜色，可以将其内部视作类似烟雾等环境，因此会涉及到内部的多次散射。

这种性质，也被称为<span style="color:red; font-weight:bold">次表面反射</span>，即光进入物体内部，不是直接直线传出，而是发生了多次反射，最终可能从另外的方向离开物体。

<span style="color:white; background-color:DimGray">其在 BRDF 基础上进行了延升，BRDF 定义的是在同一个点，发生了反射，而 BSSRDF 描述的是光线到交点后，通过内部传播，从另一个位置传出这个过程。</span>公式定义为：

$$
L(x_o,\omega_o) = \int_A\int_{H^2}S(x_i,\omega_i,x_o,\omega_o)L_i(x_i,\omega_i)cos\theta_id\omega_idA
$$

目前通过使用 Dipole Approxmiation 来模拟这种现象，光线照射到物体后，假想物体的内部出现了一个光源，在向外发光，而物体表面的相对位置（物体外），也会有一个光源。通过这样的模型，能比较好的模拟这种现象。

### 13.2.2. 布料

布料本质是一系列缠绕的纤维构成。

目前的实现方式，主要有三种：
- 将其视作散射介质，按照云雾的处理方式进行处理
- 对布料内部的各个位置上的反射详细处理
- 分别处理布料中的每一根线，最终形成完整布料

### 13.2.3. 高精度材质

在很多电脑模型中，尤其在仿真模型中，模型表面都表现都十分完美，体现为细节较少，主要体现为没有划痕。

> 如果引入足够小的细节，此处将出现光的波动性，表现为原本的白光在观察中呈现为彩色。

## 13.3. 程序生成材质

不是使用贴图等方式得到的材质，通过计算机实时计算得到对应的值，如3D材质，能够同时定义物体内部各个位置的材质。

此处主要涉及到<span style="color:red;font-weight:bold">噪声函数</span>。

# 14. 计算机动画

动画是借助人眼的视觉暂留效应，让快速切换的图片通过人脑的处理，变成一组连续的动作。

## 14.1. 关键帧动画

通过确定关键帧，在两个关键帧之间，通过前后的状态形成自然的插值，最终的效果是对整个中间过程的补充。

对于这种关键帧插值，最大的要求就是其中的变化自然，得到的中间过程更加连贯、自然。

因此，可以将这种的过程推导出插值算法，通过曲线变化模拟中间的过程，并追求中间的过程自然连贯。

## 14.2. 物理模拟

按照真实世界中的推理，利用物体受到的力，计算其加速度，从而推断中间任何时间的速度以及位置。

### 14.2.1. 质点弹簧系统

质点弹簧系统，通过一系列的质点，在中间通过弹簧连接。其中的基础单元是，一个弹簧，左右分别有一个质点。在这个基础结构中，涉及到以下的力的关系：

$$
\begin{align*}f_{a\rightarrow b} &=k_s\cfrac{b-a}{||b-a||}(||b-a||-l)\\f_{b\rightarrow a}&=-f_{a\rightarrow b}\end{align*}
$$

> 其中的 $l$ 表示弹簧正常的长度，这部分不应该计算在弹力中

在这个系统中，只是存在弹力，将会导致整个系统永远不会停止，需要在系统中引入摩擦力，使得其运动的过程逐步减弱，并最终停止，可以将阻力表示为 $f=-k_d\dot{b}$。

然而，引入这样的摩擦会，将会导致每个基础单元的两个质点同步变化，表现为两个质点在受到相同外力后，速度同步变化，并最终停止，如，空中放开弹簧，并不会出现现实情况中的上下收缩，而是两者同时减速，永远保持相同速度下落。这并不符合现实，因此为了能够将摩擦力也能影响到每个基础单元内部，需要将阻力添加在整个系统的内部。修改阻力方程，表示为下方的式子。

$$
f_b=-k_d\underbrace{\cfrac{b-a}{||b-a||}\cdot(\dot{b}-\dot{a})}_{与a到b的相对速度有关}\cdot\underbrace{\cfrac{b-a}{||b-a||}}_{描述从a到b的方向}
$$

> 其中，对a到b的速度进行了投影，最终计算的是在弹簧方向上的相对速度，这是为了避免垂直于弹簧的移动，导致其产生阻力<br>注意，<span style="color:red;font-weight:bold">摩擦力与具体的长度无关，至于两者之间的相对移动有关</span>

### 14.2.2. 有限元分析

有限元分析是通过跟踪力的传导，最终模拟还原出真实的物理效果。

目前比较多得用在工业界，用于分析力的作用。

### 14.2.3. 粒子系统

将物体视作由很多微小例子组成的整体，通过对各个粒子的状态进行分析，最后组成整个物体。

为了能简化对所有粒子进行模拟的过程中，所产生的超大计算量，利用了自然界中的鸟群的灵感。总结了在这个系统中，粒子需要满足的特性：

- 吸引力 attraction<br>各个粒子都不希望离开这个整体，在于周围的粒子拉开距离有，会有重新靠拢的趋势
- 排斥力 repulsion<br>每个粒子都不希望周围的环境太拥挤，与周围粒子的距离太近，会有拉开距离的趋势
- 对其 alignment<br>每个粒子为了保持系统的整体稳定，在周围的粒子都出现某个方向的趋势后，会尽可能保持同步

#### 14.2.3.1. 单粒子模拟

假定，某个物体，在一个速度场中运动，最终将形成一个沿着速度场移动的曲线。运动场使用$v(x,t)$表示，代表了场的任意位置的速度。

通过常微分方程，将其转换为
$$
\cfrac{dx}{dt}=\dot{x}=v(x,t)
$$

> 常微分方程，Ordinary Differential Equation，在知道其导数的情况下，希望知道对应的值。

<u>而此时，希望在给出了粒子在场中的初始位置，希望得到任意时间后，它所在的位置。</u>

##### 14.2.3.1.1. 欧拉方法

通过上一个时间的数据，推算出之后的位置，再使用相同的方法继续这个过程，向后推导。

$$
\begin{align*}x^{t+\Delta t}&=x+\Delta t\dot{x}^t\\\dot{x}^{t+\Delta t}&=\dot{x}+\Delta t\ddot{x}^t\end{align*}
$$

但是欧拉方法存在很大的不稳定性，表现为，其不能真实的模拟中间的过程，而只是关注了其实的状态，并一直延续这个状态直到设定的下一个时间。在这个过程中，很可能真实的场已经发生了变化，使得它丢失了中间的状态，并且这个叠加将使得误差不断扩大，最终完全脱离。

##### 14.2.3.1.2. 改进方法

为了改善欧拉方法中的不稳定性，得到更加正确的值，逐步发明了很多的改进方法。

> 对误差的描述，此处主要分两种：
> - 局部误差 本次移动（$\Delta t$内的移动）计算出的终点与真实终点之间的误差值
> - 全局误差 整个过程，计算出的终点与真实终点之间的误差值

- **中间方法** 顾名思义，采用了中间点的值，来修正这个过程中的异常。
  1. 使用欧拉法，得到下一个时间的点
  2. 取此时得到的起点和欧拉法得到的点连线的中点，得到中点上的速度
  3. 重新在起点使用中点上的速度计算最终的终点
   $$\begin{align*}&\begin{cases}x^{t+\Delta t}=x^t+\cfrac{\Delta t}{2}(\dot{x}^t+\dot{x}^{t+\Delta t})\\\dot{x}^{t+\Delta t}=\dot{x}^t+\Delta t\ddot{x}^t\end{cases}\\\Rightarrow&x^{t+\Delta t}=x^t+\Delta t\dot{x}^t+\cfrac{(\Delta t)^2}{2}\ddot{x}^t\end{align*}$$
- **自适应步长** 欧拉方法，大部分情况下，是因为其步长不合理，导致其数据中的误差逐步放大
  1. 使用欧拉方法，得到下一个时间的点
  2. 计算中点的速度，并计算从中点出发的终点（这里就只走 $\cfrac{\Delta t}{2}$）
  3. 比较中点出发和起点直接得到的终点之间的差距，差距较大，就使用中点的值；差距不大，就用起点的结果
- **隐式欧拉方法** 也叫反向欧拉方法，使用终点速度来更新当前时间的值
  相比起显式欧拉方法（之前介绍到的正向推理方法），更加困难，不好推理（这里比较好推理是因为模型简单）<br>
  $$\begin{aligned}x^{t+\Delta t}&=x^t+\Delta t\dot{x}^{t+\Delta t}\\\dot{x}^{t+\Delta t}&=\dot{x}^t+\Delta t\ddot{x}^{t+\Delta t}\end{aligned}$$在隐式欧拉方法中，局部的误差为 $O(h^2)$，全局误差为 $O(h)$（其中 $h$ 表示的是步长）
- **龙格库塔方法** Runge-Kutta 龙格库塔方法是一类方法，其中尤其以 **RK4** 使用比较广泛
  $$
  \begin{aligned}&\begin{cases}k_1=v(x^t,t)\\k_2=v(x^t+\Delta t\cfrac{k_1}{2},t+\cfrac{\Delta t}{2})\\k_3=v(x^t+\Delta t\cfrac{k_2}{2},t+\cfrac{\Delta t}{2})\\k_4=v(x^t+hk_3,t+\Delta t)\end{cases}\\\Rightarrow&x^{t+\Delta t}=x^t+\cfrac{1}{6}h(k_1+2k_2+2k_3+k_4)\end{aligned}
  $$

## 14.3. 运动学

用于模拟生物/机械的骨骼关节，以此来还原运动过程中，各个部位之间的变换。

目前主要可以将关节结构分为三类：
- Pin<br>考虑直接使用钉子进行固定的关节，可以在平面内，绕圆形（钉子）旋转
- Ball<br>球型关节，可以在某个球面内任意旋转
- Prismatic<br>可以有一定拉伸的关节

### 14.3.1. 正运动学

在知道各个关节的运动之后，还原出最后的状态。

通常情况下的思路，通过根节点，向下分析，子节点是父节点动作的叠加，最后得到就是最终的状态。

### 14.3.2. 逆运动学

在知道最终的状态，反向推算出各个骨骼的状态。

## 14.4. Rigging

Rigging，传动、蒙皮，为物体添加的各个控制点，来控制物体的运动。

### 14.4.1. 动作捕捉

在真人身上添加捕捉点，并最终将这些捕捉点的变化提取为一个随时间在空间中运动的曲线，最后将这个运动的过程投影到模型上，实现更加真实的动作。
