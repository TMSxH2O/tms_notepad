
> [!quote] 参考资料
> [类 - cppreference.cn - C++参考手册](https://cppreference.cn/w/cpp/language/classes)

# 1.聚合类

> [!quote] 参考资料
> [聚合初始化 - cppreference.cn - C++参考手册](https://cppreference.cn/w/cpp/language/aggregate_initialization)

聚合类，聚合初始化

## （1）使用方法

聚合初始化，表示的是列表初始化的一种形式，写法如下：

```cpp
T Object = {Arg1, Arg2, ...};
T Object {Arg1, Arg2, ...};                  // 自C++11起
T Object = {.Des1 = Arg1, .Des2{Arg2}, ...}  // 自C++20起
T Object {.Des1 = Arg1, .Des2{Arg2}, ...}    // 自C++20起
```

嵌套的类（或者类的数组，但不能数组套数组，除非数组确定长度），可以展开，将内层的初始化变量放在上层。

## （2）使用条件

必须满足以下的特征，就可以使用聚合初始化：

- 数组类型
- 无用户提供、继承或显式构造函数
- 无私有或受保护的直接静态数据成员
- 无基类
- 无虚成员函数

## （3）元素

- 对于数组，是下标递增顺序的数组元素
- 对于类，是以声明顺序的非静态成员

# 2. POD

> [!quote] 参考资料
> [C++ 具名要求：PODType（C++20 中已弃用）- cppreference.cn - C++参考手册](https://cppreference.cn/w/cpp/named_req/PODType)

> [!warning] 已过时
> POD的概念再C++20以后已废弃
> 
> 后续它的所有用途被划分得更加精细得类型要求取代，例如 `TrivialType`、`ScalarType` 或 `StandardLayoutType`。

POD，Plain Old Data。意味着该类型与C编程语言中使用的类型兼容，即可以直接以二进制形式与C库交换。

以下类型统称为POD类型：
- 标量类型 `ScalarType`
- 平凡类型 `TrivialType`
- 标准布局类型 `StandardLayoutType`
- POD类型的数组
- POD类型的CV限定版本

# 3.标量类型

> [!quote] 参考资料
> [C++ 命名要求：ScalarType - cppreference.cn - C++参考手册](https://cppreference.cn/w/cpp/named_req/ScalarType)

标量类型，`ScalarType`。可以使用 `std::is_scalar` 判断。

以下类型统称为标量类型：

- **算术类型** 整形（包括布尔、字符）、浮点型，或者其cv限定版本，通过 `std::is_arithmetic` 判断
- **枚举类型** 本质上也是整形数据，可以使用 `std::is_enum` 判断
- **指针类型** 声明指针或只想成员的指针类型变量，包括了 `nullptr_t`
- 以上类型的cv版本

# 4.平凡类型

> [!quote] 参考资料
> [C++ 命名要求：TrivialType - cppreference.cn - C++参考手册](https://cppreference.cn/w/cpp/named_req/TrivialType)
> [C++：Trivial、Standard-Layout 和 POD - 知乎](https://zhuanlan.zhihu.com/p/479755982)

> [!warning] 已过时
> 从 C++11 起生效，到 C++26 中被弃用
> 
> 可能是因为与 ==标准布局类型== 有些撞车？

平凡类型，`TrivialType`。可以使用 `std::is_trivial_v`、`std::is_trivially_copyable` 进行判断

以下类型统称为平凡类型：

 - **标量类型**
 - **没有虚函数或虚基类，使用默认构造、拷贝、移动、析构（所有的父类也必须满足）** 包括了显式标注 `= default` 也符合要求
 - 以上类型的cv版本

# 5.标准布局类型

> [!quote] 参考资料
> [C++ 命名要求：StandardLayoutType (自 C++11 起) - cppreference.cn - C++参考手册](https://cppreference.cn/w/cpp/named_req/StandardLayoutType)
> [C++：Trivial、Standard-Layout 和 POD - 知乎](https://zhuanlan.zhihu.com/p/479755982)

标准布局类型，`StandardLayoutType`。可以使用 `std::is_standard_layout` 进行判断。

满足以下要求的类型被称为标准布局类型：

- **没有虚函数或者没有虚基类**
- **对所有非静态成员变量具有相同的访问权限**
- **没有非标准布局的基类**
- **在继承关系中只有一个类中存有非静态成员变量**
- **子类的第一个非静态成员变量类型必须不是其父类**

这里配合实例代码，演示最后一条限制

```cpp
struct StandardLayoutA
{
};
struct StandardLayoutB : StandardLayoutA
{
	int v1 = 0;
	StandardLayoutA v0;
};
struct StandardLayoutC : StandardLayoutA
{
	StandardLayoutA v0;
	int v1 = 0;
};

static_assert(std::is_standard_layout_v<StandardLayoutA> == true);
// static_assert(std::is_standard_layout_v<StandardLayoutB> == true);
static_assert(std::is_standard_layout_v<StandardLayoutB> == false);
static_assert(std::is_standard_layout_v<StandardLayoutC> == false);

// B的第一个成员变量不是父类，所以依然满足；相对的，C的第一个成员是父类，所以不满足
// 这里说的父类，但实际对父类的父类也有同样的限制
```

> [!warning] 特殊情况记录
> 实际测试中，MSVC下，类型B也不满足标准布局类型；GCC可以正常返回 `true`
