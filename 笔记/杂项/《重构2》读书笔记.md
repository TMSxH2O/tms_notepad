
# 书本基本信息

- 译名：《重构：改善既有代码的设计》（第二版）
- 原名：*Refactoring: Improving the Design of Existing Code*
- 作者：Martin Fowler（马丁弗勒，软件架构师）[^1] 

# 核心内容

1. 重构是什么？
2. 为什么要重构？或者叫重构的原则、重构的好处
3. 什么样的代码需要重构
4. 重构的方法以及相关的补充

# 1. 重构是什么

作者使用了一章的篇幅，利用一个小的案例演示了一个完成的重构流程，同时也引出了作者对重构的定义：

## 1.1. 重构应该是保证接口的对外行为一致

如果没有这个前提条件，那么所谓的第一步是测试集，其实也无法成立

很多会引起对外变化的修改与其说是重构，更应该说是重新设计

## 1.2. 重构应该建立在即将修改的代码有一组可靠的测试

![[重构2-重构第一步-确保测试.png]]

## 1.3. 最小步幅重构
![[重构2-最小步幅重构.png]]

作者主张重构过程中每次修改后都能保证代码可以运行，并且在测试（这个应该是指单元测试，快速验证）后提交（commit）代码，以此来保证就算出现了大的疏漏也能直接轻松回滚到上一个可工作的状态。

> 这里用的是git的概念，所以虽然会有很多的提交（commit），但推送（push）的数量还是会进行一些限制的。当然，看作者后面的意思，这个推送应该也会控制到一天至少有一次，来保证修改的内容同步不会太滞后。

# 2. 为什么需要重构（重构的原则）

重构主要有四个目的：

1. 改进软件的设计
2. 使代码更加容易理解
3. 重构帮助找到bug
4. 重构提高编程速度

> 实际3、4可以理解为2的一部分

这里提到的重构提高编程速度，是重构后清晰的代码结构，在一个较长的开发周期上，对效率的影响。基于良好的代码开发，添加新功能的速度是越来越快，都能更好得利用已有的功能，基于已有的功能快速构建新的功能；相对的，较差的代码（一般是因为问题一直堆积导致），需要花费越来越多的时间来考虑，应该如何把新功能塞进现有的代码库，不断蹦出来的bug修复起来也越来越慢。

![[重构2-重构对开发效率的影响.jpeg]]

# 3. 什么样的代码需要重构

> 何时重构

“三次法则”：第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，就应该考虑重构。

> 主要是强调经常用到或者改动的代码模块才需要重构，那些万年不动，但是运转良好的模块其实是不需要考虑重构的。

此外，作者也提到了几种不同的重构方式

## 3.1. 见机行事的重构

一些并不会有具体安排，通常是添加新功能或者修复bug过程中顺带的重构。这样的重构对当下正在处理的任务能带来一些帮助，同时还能让未来的工作更加轻松。

- 预备性重构：让添加功能更容易<br>在添加某个新功能时，经常会遇到，之前的代码设计时并没有兼容到后续逻辑，但接口差异不大。<br>如果不进行重构，就不得不额外复制一个函数，这样就导致后续如果发生了相关的修改，就不得不一次维护两份代码；这种情况，不如在最开始时就考虑将他们提取为一个函数，后续更新维护时也会容易得多。
- 帮助理解的重构：让代码更容易懂<br>在编写代码之前，一般都需要先理解代码在做什么，才能着手修改。这里的代码可能是自己写的，也可能是别人写的。一旦出现了自己经常会花时间去思考“这段代码到底是在做什么”，那就应该考虑一下：能不能重构这段代码，令其一目了然？这样的修改带来的帮助并不仅限于将来——常常是立竿见因。
## 3.2. 有计划的重构

“即便团队做了日常的重构，依然会有些问题在某个区域逐渐累积长大，最终需要花些时间来解决，但这种有计划的重构应该很少，大部分重构应该是不起眼的、见机行事的。”

# 4. 补充

> 作者围绕重构的一些看法，我感觉还挺有意思，也都放这一块了

## 4.1. 关于“重构中的修改导致性能下降”看法

> 重构时，更清晰的逻辑比局部的性能更重要

重构过程中，为了让结构更加清晰，可能做出一些对性能或者说比较费的调整，比如文中为了让循环内做的事情更加清晰，将一个循环内的 `if` 提到另一个 `for` 中处理，导致原本一次循环解决的问题变成了两次。很多人应该都无法接受这样的性能浪费，但是在作者的看法是这样的，主要有两点：

1. 很多时候，这种小的性能损失并不会对程序整体性能带来什么影响，软件最终表现出的性能只会和代码中的一小部分有关，而其他的部分往往对总体性能贡献甚微。<br>![[重构2-重构性能下降1.png]]
2. 清晰的结构更有利于做性能优化。<br>虽然重构中的某个阶段，可能因为特定修改出现性能下降，但它让代码的结构变得更加清晰，就算后面法线性能下降比较严重无法接受，也很容易在重构后的代码上进行优化。

> 这里的内容我认为和书中2.2章的“两顶帽子”也是有一定关联的，让大家先理解：重构不等于优化。
> 
> 重构过程中并不用太过纠结性能上的损失，而是更多得关注在如何让代码变得逻辑清晰。
> 性能的问题在优化的阶段再统一进行，在各种Profile性能的工具的帮助下定位到需要优化代码，比起凭借直觉去猜测哪段代码有性能问题更加准确高效。（书中2.8）

## 4.2. 对分支开发的看法

> 书中的2.5.重构的挑战

### 4.2.1. 分支开发定义

每个团队成员在代码库的一条分支上工作，在进行了大量的开发后，才把各自修改的内容合并会主干分支，与整个团队分享。

这种做法的喊出是能保持主干不受到未完成代码的干扰，同时也保留了清晰的功能添加版本记录，在某个特定功能出现问题是比较方便撤销修改。

### 4.2.2. 分支开发带来的问题

 - 合并困难<br>在隔离的分支上工作时间越久，想将修改的内容合并回主干就越困难。为了减轻集成的痛苦，大部分人的做法是频繁从主干合并到分支，但这并不能真正解决问题。
 - 信息滞后<br>对公共代码的修改，在同步前其他分支都无法感知。
 - 和频繁重构的规划冲突<br>因为作者是比较主张“见机行事的重构”的，尤其是多个人在开发同一个模块时，就更容易出现这个问题。可能A为了让某个函数更好理解，本地对代码进行了改名，本身是一个简单的修改；但如果合并前，B同样对函数增加某个函数的重载，此时合并后的代码就会被破坏。

### 4.2.3. 替代方案

为了降低分支合并的复杂度，让分支的生命周期尽可能得短，这里主张采用的方法叫做**持续集成（Continuous Integration，CI）**，也叫基于主干开发（Trunk-Based Development）。

团队的成员应该更加频繁得向主干集成（或者说直接不用分支，直接提交到主干），这种实践避免了任何分支之间彼此的差异太大，从而极大地降低了合并的难度。

但CI也有其代价：<u>它要求必须确保主干分支随时处于健康状态，未完成的功能必须使用特性开关（feature toggle，也叫特性旗标，feature flag）限制。</u>

### 4.2.4. 更适合分支开发的场景

“对于开源项目而言，分支开发应该是更加合适的做法，因为不时会有并不熟悉（因此也不信任）的人提交修改。”

[^1]: Martin Fowler 敏捷开发方法论提出者、后端微服务架构重要推行者
