
#内存 #指针 #异常

# 基础

## 智能指针有哪些？它们的区别是什么？

- `unique_ptr` 独占所有权
	- 不能被复制，只能被移动 `move`
	- 适用于独占资源（如文件、网络连接）
	- 在 C++14 后可以使用 `std::make_unique` 进行创建
- `shared_ptr` 共享所有权
	- 采用 **引用技术**，多个 `shared_ptr` 可共享同一个对象，最后一个释放时（引用计数为0）时释放资源
	- 存在循环引用计数风险，可配合 `weak_ptr` 解决
	- 可以使用 `std::make_shared` 创建，让内存更加连续，让 `shared_ptr` 访问对象数据更加高效
- `weak_ptr` 弱引用
	- 依赖 `shared_ptr`，不会增加引用计数
	- 用于解决 `shared_ptr` 的循环引用问题
	- 可通过 `lock()` 检测指针是否有效，增加引用计数并返回 `shared_ptr`

## `shared_ptr` 的原理是什么？请手动实现。

每个 `shared_ptr` 实例只想同一个对象，与其他的 `shared_ptr` 共享同一个计数器。

当创建新的 `shared_ptr` 或拷贝现有 `shared_ptr` 时，计数器增加。

当 `shared_ptr` 被销毁（通过析构）或重置（通过 `reset` 方法）时，引用计数减少。

当计数器为0时，自动释放对象的释放。

> [!todo] 手动实现
> **TODO**

# 进阶

## 使用 `make_shared<T>(...)` 相比 `shared_ptr<T>(new T(...))` 有什么好处？

- **内存分配更加高效**<br>使用 `make_shared<T>(...)` 内部的计数器对象和实际的对象内存会被分配在一起，连续的内存有利于缓存命中，减少了调用内存分配的次数；<br>而 `shared_ptr<T>(new T(...))` 会触发两次独立的内存分配，一次想为对象分配内存，一次为计数器分配内存，且两者的内存通常是分离的；
- **异常安全性更高**<br>由于C++标准中没有规定函数参数的求值顺序，可能出现 `new T(...)` 成功后，创建 `shared_ptr<T>` 出现异常（比如正好内存不够创建一个计数器对象）；
- **代码更加简洁**<br>无需显式使用 `new`；

> [!info] 补充，`make_shared` 的坏处：
> - **无法自定义删除器**：`make_shared` 只能使用默认的 `deleter`，如果需要自定义删除器（如延迟删除对象等），仍需要使用 `shared_ptr` 构造函数；
> - **对象内存释放延迟**：由于 `make_shared` 将对象和控制块放在同一块内存，即时对象的引用计数为0，若仍有 `weak_ptr` 引用控制块（弱引用计数 > 0），整个内存块（包括对象部分）也不会释放，可能导致对象释放延迟；<u>实测这个问题不是很好验证，但引用计数为0时，析构肯定已经调用了，至于内存什么时候回收还不是很确定。</u>
