
# 重要流程分析

## 1.状态切换

状态的切换发生在 `FAnimNode_StateMachine::Update_AnyThread` 中，使用 `FindValidTransition` 找到可以潜在的可以转换的状态切换。如果找到的 `Transition` 合法，再调用 `TransitionToState`

```cpp
// Look for legal transitions to take; can move across multiple states in one frame (up to MaxTransitionsPerFrame)
do
{
	bFoundValidTransition = false;
	FAnimationPotentialTransition PotentialTransition;
	
	{
		SCOPE_CYCLE_COUNTER(STAT_AnimStateMachineFindTransition);

		// Evaluate possible transitions out of this state
		//@TODO: Evaluate if a set is better than an array for the probably low N encountered here
		TArray<int32, TInlineAllocator<4>> VisitedStateIndices;
		// 找出潜在的，合法的转换
		FindValidTransition(Context, GetStateInfo(), /*Out*/ PotentialTransition, /*Out*/ VisitedStateIndices);
	}
			
	// If transition is valid and not waiting on other conditions
	// and we're not doing a transition to self
	if (PotentialTransition.IsValid() && PotentialTransition.TargetState != CurrentState)
	{
		bFoundValidTransition = true;

		const FAnimationTransitionBetweenStates& ReferenceTransition = GetTransitionInfo(PotentialTransition.TransitionRule->TransitionIndex); //-V595
		// 执行状态转换
		TransitionToState(Context, ReferenceTransition, &PotentialTransition);

		TransitionCountThisFrame++;
	}
}
// 会尝试一次性做多个状态的转换
while (bFoundValidTransition && (TransitionCountThisFrame < MaxTransitionsPerFrame));
```

## 1.1.状态连续变化

默认情况下，动画状态机设置了一帧内进行多个状态的变化，而不会执行状态内部的逻辑。

![[UE-Animation-StateMachine-MaxTransitionsPerFrames.png|500]]

状态机节点的 “每帧最大过渡”，也就对应上面的 `MaxTransitionsPerFrame`，默认值为3，表示每次处理状态转换时，可以一次跳过三个状态。

这种情况下，因为是直接在 `Update_AnyThread` 内直接循环处理的状态转化，所以状态节点内的逻辑还没有执行，如果有些转换条件依赖了状态节点内部的逻辑（必须先执行一遍前置状态节点里的逻辑），就会表现出异常。

> [!example] 示例
> 在还原 Lyra 动画表现时，希望实现起步动画 Start 过程中，如果出现了朝向变化，提前转换到循环动画 Cycle。具体的做法是在 Start 状态内部的关联时，记录当前的朝向，用于后续更新对比。
> 如果设置了 “每帧最大过渡” 大于1，进入 Start 状态后，还没执行状态内部逻辑，就直接开始 Start 到 Cycle 的判断。而此时，初始方向的默认值为 Forward，所以，如果其他方向开始起步，就会直接判定成起步方向不等于当前方向，直接转换到 Cycle。

