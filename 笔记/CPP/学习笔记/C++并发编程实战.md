> 《C++并发编程实战》 学习笔记
> [在线文档](https://nj.gitbooks.io/c/content/)

# 一、线程管理
在每个程序中，至少会存在一个线程：即执行 `main` 方法的线程，该线程也被称为原始线程。其余线程使用传入的方法作为入口，在方法运行结束后退出。

## 1）启动线程
在C++中创建线程，对应 `std::thread` 对象。在创建线程对象时，需要指定线程对应的方法入口，在对象初始化完成后，就已经启动了线程。但此时还未决定后续的行为：
- 加入式 `join`<br>主线程等待线程结束
- 分离式 `detach`<br>主线程不等待线程运行结束
在指定了线程后续行为后（设置为加入式或分离式），线程不能再多次设置加入或分离，可以通过使用 `joinable` 进行判断（返回 `true` 表示可以设置加入或分离；反之，说明已经设置过了）。

### 1. 线程参数传递
在创建线程时，可以指定线程使用入口函数，以及函数对应的参数值。
默认情况下，此处的参数值将采用复制的形式进行记录并传入，但是可以采取类似 `std::bind` 中的 `std::ref` 来保证传入的参数使用引用的方式进行传入。

## 2）线程转移
线程对象不支持复制，但是可以进行移动（`std::move`）。线程的转移主要表示的是转移线程的所有权。
> 感觉是类似线程对象 `std::thread` 存储的是线程的控制权，而非其本身就是线程

```cpp
void some_function();
void some_other_function();

std::thread t1(some_function);           // 1
std::thread t2=std::move(t1);            // 2
t1=std::thread(some_other_function);     // 3
std::thread t3;                          // 4
t3=std::move(t2);                        // 5
t1=std::move(t3);                        // 6 赋值操作将使程序崩溃
```

# 二、线程间共享数据
用于应对多个线程之间，发生数据共享时的恶行竞争，以及随之而来的很多问题。
## 1）互斥量（mutex）
当多个对象拥有同一个互斥量时，可以通过对互斥量进行加锁的方式，只有唯一一个获取到锁的线程可以继续进行，而其他线程挂起。

为了减少代码中加锁、解锁的代码，C++中提供了一个 `std::lock_guard` 类，在构造时自动加锁，析构时解锁。