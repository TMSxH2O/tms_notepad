# 题目描述

> [!tag]- 标签
> #链表 #双指针 #分治 #排序 #归并排序

![[LeetCode-SortList.png|600]]

# 归并排序

> [!example]- 实现思路
> 
> 由于提供的是单向链表，不方便（或者说没办法？）实现类似快排的要求双向遍历的算法。此处选择的归并排序，这里的要点就有两部分：
> 
> 1. 找出链表的中点<br>可以使用快慢指针，快指针每次移动两个节点，当到达 `tail` 指针时，慢指针的位置就应该是链表的中点；
> 2. 实现归并排序<br>实现可以参考 [21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/description/)<br>通过递归，可以保证每次传入的链表都是有序链表。通过遍历，对比链表的 `front` 元素大小，来合并两个链表，返回一个合并后有序的链表；

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        return sortList(head, nullptr);
    }
  
    ListNode* sortList(ListNode* head, ListNode* tail) {
        // 截断，返回直到 tail 的链表
        if (head == nullptr) {
            return head;
        }
        if (head->next == tail) {
            head->next = nullptr;
            return head;
        }
        // 使用快慢指针，找出链表的中点
        // 快指针每次移动两个元素，到达tail时，slow指针就指向了head到tail的中点
        ListNode* slow = head, *fast = head;
        while (fast != tail) {
            slow = slow->next;
            fast = fast->next;
            if (fast != tail) {
                fast = fast->next;
            }
        }
  
        ListNode* mid = slow;
        return merge(sortList(head, mid), sortList(mid, tail));
    }
  
    // 合并两个链表，并排序，归并处理
    ListNode* merge(ListNode* head1, ListNode* head2) {
        // 使用一个临时节点，记录合并后链表的根节点
        static ListNode* temp_head = new ListNode(0);
        ListNode* temp = temp_head, *temp1 = head1, *temp2 = head2;
        while (temp1 != nullptr && temp2 != nullptr) {
            if (temp1->val <= temp2->val) {
                temp->next = temp1;
                temp1 = temp1->next;
            }
            else {
                temp->next = temp2;
                temp2 = temp2->next;
            }
            temp = temp->next;
        }
        // 将合并后，剩余的节点拼到最后
        if (temp1 != nullptr) {
            temp->next = temp1;
        }
        if (temp2 != nullptr) {
            temp->next = temp2;
        }
        // 返回的是已经合并完成，有序的链表
        return temp_head->next;
    }
};
```

时间性能：$O(N logN)$；空间性能：$O(logN)$

> [!question] 空间复杂度是怎么计算得到的？
> 这里的空间复杂度是递归的深度，二叉树的深度则为此处的 $logN$

## 优化空间性能

> [!example] 实现思路
> 为了优化这里的性能，可以考虑的做法是避免进行递归，通过循环处理子链。
> 
> 为了实现这个目的，必须提前得到链表的长度，多次遍历处理 `sub_length` 长度的子链表，让它们进行合并。

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        // 链表为空，无需处理
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        size_t node_length = 0;
        for (ListNode* cur = head; cur != nullptr; ++node_length) {
            cur = cur->next;
        }
  
        ListNode* dummy_head = new ListNode(0, head);
        for (size_t sub_length = 1; sub_length < node_length; sub_length <<= 1) {
            ListNode* cur = dummy_head->next, *pre = dummy_head;
            while (cur != nullptr) {
                // 每次遍历 2 * sub_length 个元素，组成的两个链表
  
                // 需要合并的第一个链表
                ListNode* head1 = cur;
                for (size_t i = 1; i < sub_length && cur->next != nullptr; ++i) {
                    cur = cur->next;
                }
                // 需要合并的第二个链表
                ListNode* head2 = cur->next;
                // 将第一个链表与第二个链表的链接截断，形成两个独立的链表
                cur->next = nullptr;
  
                ListNode* next = head2;
                // 第二个链表有可能为空
                if (head2) {
                    cur = head2;
                    for (size_t i = 1; i < sub_length && cur->next != nullptr; ++i) {
                        cur = cur->next;
                    }
                    // 记录下一轮需要处理的一组链表的起始节点
                    next = cur->next;
                    // 断开第二个链表和后续节点的联系
                    cur->next = nullptr;
                }
                // 归并处理两个链表
                ListNode* merged = merge(head1, head2);
                pre->next = merged;
                while (pre->next != nullptr) {
                    pre = pre->next;
                }
                cur = next;
            }
        }
        return dummy_head->next;
    }
  
    // 合并两个链表，并排序，归并处理
    ListNode* merge(ListNode* head1, ListNode* head2) {
        // 使用一个临时节点，记录合并后链表的根节点
        static ListNode* temp_head = new ListNode(0);
        ListNode* temp = temp_head, *temp1 = head1, *temp2 = head2;
        while (temp1 != nullptr && temp2 != nullptr) {
            if (temp1->val <= temp2->val) {
                temp->next = temp1;
                temp1 = temp1->next;
            }
            else {
                temp->next = temp2;
                temp2 = temp2->next;
            }
            temp = temp->next;
        }
        // 将合并后，剩余的节点拼到最后
        if (temp1 != nullptr) {
            temp->next = temp1;
        }
        if (temp2 != nullptr) {
            temp->next = temp2;
        }
        // 返回的是已经合并完成，有序的链表
        return temp_head->next;
    }
};
```

时间性能：$O(N logN)$；空间性能：$O(1)$

没有引入额外的空间
