# 题目描述

> [!tag]- 标签
> #数组 #动态规划 #矩阵

[64. 最小路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked)

![[LeetCode-MinimumPathSum.png|600]]

## 动态规划

> [!example]- 实现思路
> 由于路径的方向只能是向下或向右，而最终的总长度值是传递的，根据动态规划的思想，每个格子上的最小路径和，可以通过它的左边或上面的格子的最小路径和，计算其中最小值得到。
> 
> 到这一步，`dp` 需要保存的是什么也就清楚了：
> `dp[i][j] = min(dp[i-1][j], dp[i][j-1] + nums[i][j]`

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        size_t m = grid.size(), n = grid.front().size();
        // 额外创建了一行和一列，可以避免判断边界情况，使用最大值作为非法值就可以利用min直接获取到有效值
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));
  
        // 在dp[i][j]保存的是 min(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1]
        for (size_t i = 1; i <= m; ++i) {
            for (size_t j = 1; j <= n; ++j) {
	            // 需要特殊处理dp[1][1] = grid[0][0]
                if (i == 1 && j == 1) {
                    dp[i][j] = grid[0][0];
                    continue;
                }
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1];
            }
        }
        return dp[m][n];
    }
};
```

时间性能：$O(N)$；空间性能：$O(N)$

## 优化空间

> [!example]- 实现思路
> 这里其实可以发现，并没有要求不能修改原本的数组，每个值并不需要多次读取，直接用 `dp` 的值覆盖掉对应的 `nums` 值对后续的计算没有影响。

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        // 遍历原本的数组，计算将grid[i][j]更新为当前格子的最小路径和
        // min(grid[i-1][j], grid[i][j-1]) + grid[i][j]
        for (size_t j = 0; j < grid.size(); ++j) {
            auto& cur_line = grid[j];
            // 处理边界情况，处理索引等于0的情况，避免发生越界
            if (j > 0) {
                const auto& pre_line = grid[j - 1];
                for (size_t i = 0; i < cur_line.size(); ++i) {
                    cur_line[i] += i ? std::min(pre_line[i], cur_line[i - 1]) : pre_line[i];
                }
            }
            else {
                for (size_t i = 0; i < cur_line.size(); ++i) {
                    cur_line[i] += i ? cur_line[i - 1] : 0;
                }
            }
        }
  
        return grid.back().back();
    }
};
```

时间性能：$O(N)$；空间性能：$O(1)$
