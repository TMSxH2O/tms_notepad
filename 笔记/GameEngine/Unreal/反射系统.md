
> [!info] 定义
> 反射是程序运行时检查自身的能力。
> 
> by [虚幻属性系统（反射） --- Unreal Property System (Reflection)](https://www.unrealengine.com/zh-CN/blog/unreal-property-system-reflection)

在Unreal引擎中，**反射系统** 是支撑蓝图、序列化等核心功能的底层机制。它通过编s时生成类型元数据（Metadata），使得C++代码在运行时能够动态查询和操作类、属性及方法。

# 1.使用方法

在UE中，提供了非常便利的使用方式，只需要在需要反射的类、结构体、模板、函数等，上面增加特定的宏标记，指定其需要进行反射，就会让反射系统自动处理支持对其进行反射。

其中存在一些确定，所有的对象（Object）都必须继承 `UObject` 类。

> [!question] 对象（`UObject`）和结构体（`UStruct`）的差异？
> 
> 结构体推荐只用于简单数据类型，不提供复杂的交互逻辑。
> 
> 简单数据类型也表示它的构造、复制、析构尽可能不会执行特殊的处理逻辑。且构建、复制效率较高。

> [!info] 提示
> 结构体（`UStruct`）并不要求必须是 `struct`，只要没有继承 `UObject` 的类或结构体，都可以视作 `UStruct`。

## 1.1.类型概述

> [!quote] 参考资料
> [《InsideUE4》UObject（二）类型系统概述 - 知乎](https://zhuanlan.zhihu.com/p/24445322)
> 有对照C#的Type

```plantuml
Assembly <.. Module
Module <.. Type

Type <.. ConstructorInfo
Type <.. EventInfo
Type <.. FieldInfo
Type <.. PropertyInfo
Type <.. MethodInfo
Type <.. ParameterInfo
Type <.. Attributes
```

 - `Assembly` 程序集，通常是表示一个dll（编译的模块）
 - `Module` 程序集内部的子模块划分
 - `Type` 表示的就是Class信息，完整描述了一个对象的类型信息。并且Type之间也可以通过BaseType、DeclaringType之类的属性来形成Type关系图
 - `ConstructorInfo` 表示了Type的构造函数
 - `EventInfo` 表示了Type中定义的event事件（可能是指UE里的delegate？）
 - `FieldInfo` 表示类成员变量（字段），得到后可以动态读取或修改值
 - `PropertyInfo` 表示了Type中的属性，类比C++中的get/set方法组合，得到后可以获取设定属性值
 - `MethodInfo` 表示了Type中，获取方法后可以动态调用
 - `ParameterInfo` 表示了方法中的一个个参数
 - `Attributes` 值得是Type上附加的属性，C++中支持不算好，clang编译器有提供支持，可以理解为在特定的位置（类、成员变量、函数、枚举等）增加额外的标记信息

## 1.2.反射方案

C++原生并不支持反射，只提供了一个RTTI，但实现非常薄弱，不是很推荐使用。

通常比较高效的实现，就是利用C++的模板，将反射所需的信息，注册到反射系统中，保存成反射信息类。对照UE里的 `UClass`/`UStruct`、`UField` 等。

但如果每个类注册都需要手写实现，就显得过于繁琐了，因此，在UE中，是借助了 UHT 实现，根据代码中标注的宏信息，生成代码。UHT 生成的代码，由 UBT 处理，编译最后会和源代码链接到一起，自动完整反射信息的注册。（比较类似 Qt 的实现方式）

> [!question] 为何是生成代码而不是数据文件？
> > 这里的数据文件，是指类型的数据信息，比如类名、大小等反射信息。
>
> 参考 [《InsideUE4》UObject（三）类型系统设定和结构 - 知乎](https://zhuanlan.zhihu.com/p/24790386)
> 简单来说就是避免不一致性，否则又需要有机制去保证数据文件和代码能够匹配。同时，跨平台需求也很难保证结构间的偏移都一直。因此，还不如直接选择最简单的生成代码，一起编译最后链接进去的方案。

# 2.UE反射流程分析

> [!quote] 参考资料
> 
> [虚幻引擎编程反射系统实现_unreal反射机制怎么实现-CSDN博客](https://blog.csdn.net/X_Bai01/article/details/146296741)
> [UnrealEngine - 反射系统分析 - lawliet9 - 博客园](https://www.cnblogs.com/lawliet12/p/17272835.html)
> [UE4反射基础一：揭秘UBT生成代码、UObject注册、UClass及CDO生成 - 知乎](https://zhuanlan.zhihu.com/p/427575094)

> [!info] 反射过程的重要工具
> - Unreal Header Tool（UHT）<br>用于 ==预处理源代码文件的工具==，它可以识别 `UCLASS`、`UFUNCTION` 等宏，并通过生成额外的 C++ 代码来扩展类的功能。UHT 还可以用于生成反射信息，例如类的元数据和属性西悉尼，以便在运行时进行蓝图交互等操作。
> - Unreal Build Tool（UBT）<br>用于 ==编译和链接 UE4 项目的构建系统==。它可以自动管理项目中的依赖项，并生成可执行文件和动态链接库等二进制文件。UBT 还可以执行诸如打包、部署和测试等其他工作。
>
> UHT 和 UBT 两个工具在 UE 开发中密切相关，UHT 生成的反射信息需要在 UBT 中使用，注册反射所需的信息。

1. 标注宏信息（如 `UCLASS`、`USTRUCT`、`UFUNCTION`等）
2. 包含头文件 `#include "${filename}.generated.h"`<br>该头文件由UHT工具扫描后生成，其还会附带生成一个 `${filename}.gen.cpp` 的源文件。

> [!info] UHT生成文件的功能
> 1. 生成了一个或多个 **辅助类**（根据 `UCLASS` 和 `USTRUCT` 等标注的结构数量），收集标注了宏信息的结构，该辅助类构造函数会返回一个构造好的类信息类（与不同的宏对应）
> 2. 定义一个 `FCompileDeferInfo` 静态变量，其构造函数在启动时将辅助类的信息导入到一个全局的容器中，启动时会遍历这个容器，构造好类型对应的 `UClass`（或 `UStruct`、`UEnum` 等类型）对象。

## 2.1.类信息类图

```plantuml
class UMetaData
note left
元数据信息
<i>存放在Package里面？</i>
end note
class UField
class UEnum
class UStruct 
class FField
class FProperty
class UProperty
note bottom
在UE4.25以后的版本中被废弃
改为使用 <u>FField/FProperty</u>
end note

UObject <|- UInterface

UObject <|-- UField
UObject <|-- UMetaData
UMetaData -* UField

UField <|-- UEnum
UField <|-- UStruct
UField <|-- UProperty
UEnum -[hidden]right- UProperty
UProperty -* UStruct

UStruct *- FField
FField <|- FProperty

UStruct <|-- UScriptStruct
UStruct <|-- UClass
UStruct <|-- UFunction
UFunction -* UClass
```

> [!warning] 注意
> `UStruct` 可能引起歧义，实际对应C++中 `struct` 的是 `UScriptStruct`，应该是最早命名时导致的问题，后续已经不方便调整了。

> [!question] 问题1：为什么 `UField` 要继承 `UObject`？
> 这个问题，其实也是在问，为什么类型数据同样继承于 `UObject`？
> 
> 反过来想，如果不继承会怎么样？这里尝试把继承链断开，类型数据自成一派，其实也未尝不可。这里列举以下 `UObject` 支持的功能列表，再来分析其中哪些对于类型系统来说是必要的：
> 
> - **GC** 可有可无，类型系统一开始就分配了就不会释放，当前GC也是利用了类型系统来支持对象引用遍历。
> - **反射** 略，本身就是在 `UObject` 下来扩展反射的功能，所以不是为了这个功能。
> - **编辑器继承** 同样可以没有，编辑器就是利用类型数据来进行编辑的，当然，让我们在蓝图中创建函数变量等操作，其实也可以视作是在编辑类型数据。
> - **CDO** 不需要，每个类型的类型数据只有一份，CDO是用来对象身上的。
> - **序列化** ==必须有==，类型数据当然需要保存下来，比如蓝图创建的类型。
> - **Replicate** 用处不大，因为目前网络见的复制也是利用了类型数据来进行的，类型数据本身的字段的改变复制，并没有什么应用场景。
> - **RPC** 与 Replicate 类似，同样无所谓。
> - **自动数据更新** 也不需要，类型数据正常来说不会频繁变动。
> - **统计** 可有可无
> 
> 整理后可以发现，`UObject` 支持的功能中，只有序列化对类型系统是非常必要的功能，其他的功能都属于锦上添花。所以归结起来，应该是本着统一的思想，就让所有类型数据都基于 `UObject` 了，这样序列化逻辑也不需要实现两套。虽然看起来不是那么存粹，但总体来说是利大于弊。
> 
> 在使用过程中，可以使用 `Instance->GetClass()` 来获取实例对象的类型数据，类型数据自己也可以再调用 `GetClass()` 函数，返回的是自己，以此可以区分对象和类型数据。

> [!question] 为什么需要基类 `UField`？
> `UStruct` 表示的是所有的聚合类型，那为什么不直接 `UEnum`、`UProperty`、`UStruct` 继承 `UObject`。可能的远因如下：
> 
> - 为了统一所有的类型数据，让他们都有一个基类，方便管理。同时也能和 `UObject` 对象之间做出区分。
> - 为了增加Meta数据（`UMetaData`），应该在他们的基类中存储。<s>但实际观察 `UField` 的源码，`UMetaData` 是从 Outermost 的 `UPackage` 对象管理，和这里的说法不太一样？</s>
> - 方便为类型数据类增加一些统一的方法。

## 2.2.生成代码解析

分别解析 `.generated.h` 和 `.gen.cpp` 两个文件。两个文件都被放在了对应项目的 `Intermediate\Build\${Platform}\UnrealEditor\Inc\${ProjectName}\UHT` 目录下。

### 生成头文件

> UE版本 5.5.1

核心入口是找到 `GENERATED_BODY` 宏的定义，其中，`CURRENT_FILE_ID` 都被定义在每个生成头文件的最后。

```cpp
${CURRENT_FILE_ID}_${__LINE__}_GENERATED_BODY
```

在 `GENERATED_BODY` 宏里，有四个宏（只列出了宏最后一段的名字）：

1. `RPC_WRAPPERS_NO_PURE_DECLS` <br>定义了标注 `UFUNCTION` 的函数相关 RPC 接口
2. `CALLBACK_WRAPPERS` <br>**暂不确定具体的作用，在测试的类定义中为空**
3. `INCLASS_NO_PURE_DECLS` <br>使用了重要的 `DECLARE_CLASS` 声明了很多类信息（其中的 `static UClass* GetPrivateStaticClass()` 接口也很重要，关系到了常用的 `StaticClass()` 获取类型数据的接口）
4. `ENHANCED_CONSTRUCTORS` <br>声明几个特殊的构造接口。里面还提供了 `static void __DefaultConstructor(const FObjectInitializer&)` 静态接口，使用静态成员函数封装一层构造函数，方便把函数指针传给其他地方使用

> [!info] 重要接口
> `GetPrivateStaticClass` 接口关系到重要的 `StaticClass` 和 `GetClass` 接口来获取类型数据。它的实现在生成的源文件中，使用 `IMPLEMENT_CLASS_NO_AUTO_REGISTRATION` 宏生成。

### 生成源文件

主要做的事，就是与头文件中的 `DECLARE_FUNCTION` 对应，使用 `DEFINE_FUNCTION` 宏定义接口实现。

其中，`IMPLEMENT_CLASS_NO_AUTO_REGISTRATION` 在定义 `GetPrivateStaticClass` 接口的同时，还声明了重要的辅助对象 `FClassRegistrationInfo Z_Registration_Info_UClass_##TClass`（cpp 文件中的全局变量）。

将类型信息传入，把懒汉单例对象（类型数据 `UClass`）保存在 `GetPrivateStaticClass` 函数的局部静态变量里。

还有一个 `Z_Construct_UClass_ARPGCharacter` 接口，包含了完整的 Meta 信息，最后是通过 `FRegisterCompiledInInfo` 静态全局变量在引擎启动时自动注册。

## 2.3.类型信息收集

> 在大钊的原文中，提到的 `FCompiledInDefer` 在后续版本（具体版本不确定，但评论区中有人提到是UE5）已经被替换为 `FRegisterCompiledInInfo` 类。
> 因此，部分逻辑已经有变化，此处以最新实现为准。

> [!question] 思考：为何需要延迟注册而不是直接在 static 变量初始化时执行？
> 首先思考 static 变量初始化时执行的好处，确保安全，实现简单。但带来的坏处是，引擎里大量的对象注册都被放在启动时执行，会影响启动的速度，直观的表现就是，引擎启动后完全没有反应，等了好久才弹出窗口，用户体验不佳。
> 因此就需要延迟注册，至少是先弹出加载的窗口，之后再利用多线程、懒加载等方式也好去注册，就能大幅优化程序运行的体验。

类型系统注册，是通过 `void RegisterCompiledInInfo(...)` 函数注册，之后延迟调用接口。

在这里，可以看到其中使用到了 `FDeferredRegistry<T>::AddRegistration` 注册，但并没有立刻执行，全部都保存在 `FDeferredRegistry<T>::Registrations` 内。等到 `FDeferredRegistry<T>::DoPendingOuterRegistrations` 函数内（被 `ProcessNewlyLoadedUObjects` 调用），才真正执行注册。

![[UE-Reflect-ClassDeferredRegistry.png|300x]]

```plantuml
start
:ProcessNewlyLoadedUObjects;
:UClassRegisterAllCompiledInClasses;
note right
调用每个UClass的InnerRegister函数InnerRegister
就等于对应类型的StaticClass静态函数内部会触发
---
Class的注册最特殊，内部额外做了处理，用于是被热更
将所有的UClass进行了记录
end note
end
```

# 常见Meta的作用

## 使用 `UFUNCTION` 宏标记的函数如何暴露给脚本而不影响原本的使用

在 UHT 生成时，在 `.generated.h` 中新增 `exec##FUNC_NAME` 的函数，在 `.gen.cpp` 中调用原本的函数。

## 函数标注为 `BlueprintImplementableEvent` 就不能写对应的函数实现但依然可以正常编译

在 UHT 生成时，会为对应的函数增加函数定义。

```cpp
// 在头文件中，成员增加了一个脚本实现的函数
UCLASS()
class ...  // 函数定义省略
{
	GENERATED_BODY()
	
public:

	UFUNCTION(BlueprintImpementableEvent, Meta = (DisplayName = "OnDeathFinished"))
	void K2_OnDeathFinished();
};

// 在对应的 xxx.gen.cpp 中
// 会自动生成如下代码

static const FName NAME_##ClassName##_K2_OnDeathFinished = FName(TEXT("K2_OnDeathFinished"));
void ${ClassName}::K2_OnDeathFinished()
{
	UFunction* Func = FindFunctionChecked(NAME_##ClassName##_K2_OnDeathFinished);
	ProcessEvent(Func,NULL);
}
```
