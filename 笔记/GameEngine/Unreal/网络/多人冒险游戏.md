
> [!quote] [【国语】虚幻引擎UE5和C++多人联机：打造在线合作冒险游戏](https://www.bilibili.com/list/watchlater?bvid=BV12edbYBEh8&oid=114305269830350&p=7)

# 1.基础

## 1.1.多人游戏概述

在UE中，采用 客户端-服务器模型（CS模型）

只有一个权威服务器，其他的所有客户端都链接到服务器。唯一正确的游戏版本只出现在服务器上，而其他客户端都只是在模拟。在权威服务器上的内容发生更新时，会将改变发送到客户端，通知他们进行更新。

> [!question] CS模型相对P2P模型的好处？
> P2P模型下没有权威服务器，因此，当一个客户端发生改变时，它会将自己的状态直接同步到其他客户端，这也意味着所有的客户端之间都会进行链接。当用户数量增加时，它的复杂度也会指数上升。
>
> 相对的，CS模型下，对客户端而言，只需要关注与服务器的链接与通信即可，增加用户时，复杂度也是线性变化。

网络情况大致可以分为：
- 在同一台机器上进行游戏；
- 在同一个本地网络（LAN）的多个计算机上进行游戏；
- 在不同地区的机器，通过互联网进行游戏；

UE的复制系统（Replication），通过反射的方式，当对象的数据发生更新时，会自动同步标记需要更新的成员变量。

## 1.2.网络模式

网络模式，NetMode，用来表示玩家在多人游戏中所扮演的角色。

- `NM_Standalone`<br>独立模式，可以视作一个服务器，不会接受任何的远程链接。通常用于实现单人游戏或者本地多人（支持多玩家对象）
- `NM_DedicatedServer`<br>专用服务器，游戏作为服务器运行，主持网络会话，接受远程网络链接。本身并不提供仅客户端必要的功能（比如画面、声音、输入等），因此，无法直接在上面进行游戏，同时性能更高。通常用于保证竞技游戏（必须保证公平）或是大规模玩家在线的场景。
- `NM_ListenServer`<br>监听服务器，可以游玩的同时担任权威服务器，主持管理整个游戏并同步状态到其他链接的客户端。由于监听服务器也同样作为客户端，等于有一个客户端直接在服务器上进行游戏，拥有完整的游戏状态信息，相比其他客户端拥有巨大优势，因此更常见于休闲合作类型的游戏。
- `NM_Client`<br>客户端，用于链接到某个服务器。


|                    | 可以游玩 | 具有权威性 | 支持客户端链接 |
| ------------------ | ---- | ----- | ------- |
| NM_Standalone      | √    | √     |         |
| NM_ListenServer    | √    | √     | √       |
| NM_DedicatedServer |      | √     | √       |
| NM_Client          | √    |       |         |

## 1.3.复制系统

UE的 Replication System，用于保证所有客户端中的数据都尽可能与服务器上的表现一致。

服务器会对每个客户端创建连接，通过 Channel（通道）连接到客户端；并且对每个 Actor 创建专属的 Actor Channel 来实现复制。因此，复制操作的控制粒度实际是在 Actor 层级，如果需要对某个 Actor 保持同步，就应该给对应的 Actor 设置为可复制 `bReplicates` 为 true。

默认情况下，大部分的 Actor 的可复制都被设置为 false，所以仅在本地有效。

复制系统中，最常见的操作如下：

- 创建和销毁（Creation and Destruction）<br>当在服务器上生成一个可复制的Actor时，它会自动在所有连接的客户端上生成自己的远程代理。服务器上创建可复制的Actor，就会在客户端上创建一个Actor的副本。同理，当服务器上销毁对应的Actor时，也会通知客户端，将对应的Actor副本销毁。
- 移动复制（Movement Replication）<br>当开启移动复制（`bReplicateMovement`），将会自动复制Actor的位置、旋转和速度等信息（MovementComponent）。
- 变量复制（Variable Replication）<br>当开启变量复制，将会自动复制Actor的内部成员变量值。
- 远程过程调用（Remote Procedure Calls，RPCs）<br>在网络中的某端触发目标端的函数调用，最终在目标端上执行函数。有三种不同的RPCs类型：服务器（在服务器上执行，由客户端调用）；客户端（由对应的Actor客户端执行，在服务器调用）；组播（在连接的每台机器上运行）。

### 变量复制

变量复制，Variable Replication，支持将服务器上的成员变量值复制到关联的客户端。

需要在成员变量上增加 `Replicated` 标记，并且类型增加实现 `GetLifetimeReplicatedProps` 函数。

```cpp
// 头文件
UCLASS()
class ATestActor : public AActor 
{
	GENERATED_BODY()

	/// 测试复制的成员变量
	UPROPERTY(Replicated)
	float ReplicatedVar;

	// 必须在函数内明确复制的逻辑
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
}

// 源文件
void ATestActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	
	// 指定需要复制的成员变量
	DOREPLIFETIME(ATestActor, ReplicatedVar);
}
```

> [!info] 细节
> 开启了变量复制的成员，在蓝图中使用时，右上角会出现两个小球的标记，表示成员变量已开启复制。

### 复制通知

在变量复制时，还可以额外触发关联的复制通知函数。通知函数的命名通常使用 `OnRep_[变量名]`。

需要在变量复制的基础上，将成员变量上的标记改为 `ReplicatedUsing = [复制通知函数]`

```cpp
// 其他代码与上面的变量复制示例一致，不再重复
/// 测试复制的成员变量
UPROPERTY(ReplicatedUsing = OnRep_ReplicatedVar)
float ReplicatedVar;

// 指定函数支持反射，内部的逻辑不是非常重要，所以略过
UFUNCTION()
void OnRep_ReplicatedVar();
```

在蓝图中也可以在变量的细节面板上指定变量复制或时复制通知，当切换到复制通知时，会自动在当前蓝图类中添加对应 `OnRep_[变量名]` 函数。

### 远程过程调用

远程过程调用，Remote Procedure Calls（RPCs），表示在网络的一台机器上触发，但是由指定的另一端进行执行的调用方式。可以分为以下三类 RPCs：

1. 服务器（Server）：在客户端调用，最后在服务器执行；
2. 客户端（Client）：在服务器调用，最后在某个（单个）客户端执行；
3. 组播（NetMulticast）：在服务器调用，链接的所有机器上执行（包括服务器本身）；

RPCs函数的可靠性，顾名思义，用于确定是否必须确保成功调用到目标机器上的函数。分为可靠 `Reliable` 或不可靠 `Unreliable`。其中的不可靠通常用于一些不是非常重要的任务，例如玩家移动就被设置为不可靠，这是因为每帧都会调用，数据量很大，而且每帧都调用的话部分数据丢失也不会造成非常严重的影响，每帧都有机会纠正之前错误的信息。

> [!warning] 警告
> 不应该滥用可靠的RPC，尤其是非常频繁的远程调用，比如导致网络任务队列溢出、玩家被强制断开连接等（？）

声明的方式是在函数（这些RPC函数的命名规范是以 `[RPC类型]RPC` 开头，比如想写一个 `Test` 的Server RPC测试函数，规范的命名就是 `ServerRPCTest`）上增加对应类型的RPC标记（比如 `Server`、`Client`、`NetMulticast`），并且指定调用的可靠性（比如 `Reliable`），最后在源文件中实现时，实现对应函数名 + `_Implementation`。比如声明了 `ServerRPCTest` 的 RPC 函数，在源文件中实现的就应该时 `ServerRPCTest_Implementation` 的对应函数。

> [!example] 可选扩展
> RPC参数验证，需要在函数定义时，增加 `WithValidation` 标记，之后需要在源文件中，实现对应函数名 + `_Validate` 的实现（与 `_Implementation` 类似）。

```cpp
// 头文件
UCLASS()
class ATestActor : public AActor 
{
	GENERATED_BODY()

	// 服务器可靠RPC函数
	// 这里的 WithValidation 用于验证调用是否合法，是一个可选的标记，增加之后必须实现对应的 _Validate 函数
	UFUNCTION(Server, Reliable, WithValidation)
	void ServerRPCTest(int InVal);

	// 客户端可靠RPC函数
	// 由服务器调用，根据Actor对象的Owner判断应该在哪个客户端上执行
	UFUNCTION(Client, Reliable)
	void ClientRPCTest();
}

// 源文件
// 服务器RPC函数的实现
void ATestActor::ServerRPCTest_Implementation(int InVal)
{
	// 在服务器上执行的逻辑
}

// 服务器RPC函数的验证函数，仅在加上了 WithValidation 后需要
// 如果返回值为 true，表示输入值合法，继续执行实现逻辑；
// 反之，如果返回 false，客户端将被断开连接；
bool ATestActor::ServerRPCTest_Validate(int InVal)
{
	// 通常是用来验证输入值是否合法
}

// 客户端RPC函数的实现
void ATestActor::ClientRPCTest_Implementation(int InVal)
{
	// 在对应客户端上执行的逻辑
	// 通常用与服务器触发某个客户端的特定逻辑，比如某个玩家受到攻击后在受到攻击的客户端播放受伤的视觉效果（别人看不到视觉效果，比如窗口震动），而不会影响其他客户端
}
```

> [!warning] 所有权（Owner）
> 
> 只有当前机器上拥有所有权的Actor，才能调用对应的服务器RPC，比如尝试通过其他玩家拥有的Actor，调用服务器RPC，并没有被成功调用。
> 
> 相应的，如果时客户端RPC也是通过Owner判断具体应该在哪个客户端中执行对应的RPC函数。

## 1.4.网络角色

每个Actor的网络角色，包含了哪个角色用于控制当前角色的权限。其中，权威角色（Authority）表示对当前角色具有完全控制权，它负责将当前Actor的所有信息复制给网络多人会话的其他机器。

在UE中，服务器总是具有权限，而客户端只是具有相应的代理，因此复制永远是从服务器到客户端。

可以通过 `AActor::GetLocalRole` 获取Actor的角色类型：
- `ROLE_None`<br>表示网络中没有该角色，并且不会复制当前角色
- `ROLE_Authority`<br>表示当前角色是权威的，并且正在将信息复制到远程代理
- `ROLE_SimulatedProxy`<br>模拟代理，没有控制权的代理对象，完全由服务器上的权威角色控制（最常见的代理类型）
- `ROLE_AutonomouseProxy`<br>自主代理，一种代理对象，并不完全由服务器控制，本地依然可以操控相关的对象，常用于部分客户端直接控制的Actor，避免延迟过高导致的表现异常（比如角色的Pawn）

>[!example] 判断当前机器是服务器还是客户端
>比较常见的一种写法是通过 `AActor::GetLocalRole` 的返回值判断：
>```cpp
> // 服务器
> // 与 AActor::HasAuthority 等价
> if (GetLocalRole() == ROLE_Authority) {  
> 	// 专用服务器或监听服务器
> }
> // 客户端
> else {
> }
> ```

