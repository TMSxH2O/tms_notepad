
> [!quote] 参考资料
> [《InsideUE4》UObject（一）开篇 - 知乎](https://zhuanlan.zhihu.com/p/24319968)

# 1.开篇
# 1.1.引入对象 `UObject` 带来的利与弊

利：

1. **万物可追踪**。有了统一基类Object，就可以根据基类来设计Object类型的指针，追踪到所有的派生对象。在引擎中的表现，就是记录各个资源之间的引擎、使用关系，甚至将所有对象的引用图给展示出来。
2. **通用的属性和接口**。得益于继承继承，在Object可以加上可以直接为所有的对象类型，增加属性和接口。（面向对象的好处）
3. **统一的内存分配释放**。使用不同的GC回收方案，管理和回收不再使用的对象。
4. **统一的序列化模型**。在Object里提供了默认的序列化接口，如果需要自定义，只需要重载序列化接口即可，实现序列化更加方便。

弊：

1. **臃肿的Object**。面向对象（继承）导致的问题，每当为对象Object添加一项新的通用功能，所有的对象都会挂上相应的代码。在UE里，`UObject` 就已经拥有超过几十个接口，很难掌握。
2. **不必要的内存负担**。某些属性可能并不是所有对象都需要用到，但是由于设计问题（不确定用到，但是为了接口方便，就直接放到了Object）。
3. **多重继承的限制**。比如C类多重继承A和B类，如果A和B都是Object，正如上面提到的，会导致C类中包含了两份成员变量，造成浪费。但是直接让A和B类都是用虚继承也不是很靠谱，因此通常的处理方法就是限制不允许多继承Object。
4. **类型系统的割裂**。由于 `UObject` 是UE里引入的对象概念，在原生C++中并不支持，且使用也完全不同，需要用户自己判断哪些对象应该继承Object，哪些不用？哪些可以GC，哪些只需要用智能指针？C++对象里new了Object对象该怎么管理，Object对象里new了C++对象什么时候释放？

规避 `UObject` 的弊端：

1. **针对太过复杂的Object基类**。将 `UObject` 拆解成多个层级，子类按需求进行继承，而不是全部直接继承 `UObject`。
2. **针对内存问题**。（大钊在UE4，具体版本未知下测试大小为 56，我测试UE5.5.1下大小为48）目前UE的Object类大小还可以接受，且官方还在想办法优化，这种情况下，应该考虑控制Object对象的数量，实际的游戏中，并不太需要构建太多的对象。
3. **规避多重继承**。只继承一个 `UObject` 类，其他的接口（或者说行为）通过继承 interface 来实现；或者通过调整为组合的方式实现（组件模式）。
4. **多多学习了解**。越是精巧的设计越是难以理解。不过一方面UE提倡在BP中实现游戏的逻辑，C++充当BP的VM，就可以完全对用户隐藏掉复杂性。另一方面，UE在UObject上也提供了大量的辅助设计，如 `UCLASS` 等宏的遍历，`NewObject` 方面的接口，UHT的自动生成代码，已经尽量避免用户直接涉及到 `UObject` 的内部细节。