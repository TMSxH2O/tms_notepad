
#静态库 #动态库 #ABI

# 基础

## 什么是静态库？

> 初版的定义：
> 静态库可以大致理解为一个提前编译好的对象文件(.obj)集合。后续可执行文件链接使用到静态库时，在链接阶段，会提取静态库中的对象数据，复制一份到可执行文件中。

静态库是多个编译好的代码块集合（类似零件仓库）。程序编译时，链接器会从中取出需要的代码零件，直接组装到最终的可执行文件中，这样生成的程序就能独立运行不再需要原库文件。

## 什么是动态库？

> 动态库是提前编译好的代码块（类似接口的工厂）。在程序编译时，链接器只会记录其中数据的偏移位置，最后程序运行时依然需要由系统加载并把执行程序管理到动态库的对应位置，来实现调用。

动态库像共享工具箱（如小区公用五金箱）。编译时程序只记录需要哪些工具，真正运行时才会去箱子里取用。多个程序可共用同一套工具，节省存储空间，但程序运行必须保证该工具箱存在于系统中。

## 动态库如何实现“一次编译，多次使用”？

动态库通过操作系统的内存映射技术，运行多个进程共享同一份动态库的代码段，避免重复加载。

## 静态库与动态库的优劣对比

|         | 静态库          | 动态库                           |
| ------- | ------------ | ----------------------------- |
| 可执行文件体积 | 大，内部包含所有库的代码 | 小，仅包含了引用                      |
| 运行时以来   | 无需外部库，独立性高   | 依赖外部库，且必须确保版本（ABI）            |
| 内存占用    | 独立内存         | 多程序共享利用率高                     |
| 更新维护    | 必须重新编译整个程序   | 在兼容（ABI）时，无需编译可执行文件，可以直接替换动态库 |
| 性能      | 无额外开销        | 有轻微运行时加载开销                    |
| 调试难度    | 符号直接嵌入，易于调试  | 必须提供源库文件以及对应的符号文件             |

# 进阶

## 动态库的版本兼容性问题如何产生？开发时应该如何避免发生不兼容？

兼容性问题产生的原因：

 - 函数的参数、返回值变化
 - 内部数据变化，包括增删成员变量或调整成员顺序、增减虚函数或调整虚函数顺序
 - 调整导出符号的名称

规避的方法：

 - 通过版本号控制，利用主版本号区分不兼容的更新，次版本号来区分可兼容的更新
 - 代码实现是尽可能对外隐藏细节（比如仅导出PImpl或抽象类），增加新的API时依然保留久API但标注废弃

## 在大型 C++ 项目中，如何设计静态库与动态库的混合使用策略？需要考虑哪些关键因素？

 - 对于底层的核心模块，这类必须包含的模块，动态库的插拔特性对他们并没有什么意义，并且还会导致启动速度降低，应该使用静态库；
 - 对于上层的功能模块，如果开发初期接口变动快（还没有确定稳定的接口），可以暂时考虑使用静态库，等接口相对稳定后，为了减少编译耗时，减少内存占用，应该使用动态库；
 - 对于第三方库，应该优先考虑使用动态库，使用版本控制；



