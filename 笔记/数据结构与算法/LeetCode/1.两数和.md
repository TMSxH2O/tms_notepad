
# 题目描述

> [!tag]- 标签
>  #数组 #哈希表

[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)

![[LeetCode-TwoSum.png|600]]

# 暴力法

> [!example]- 实现思路
> 通过两层循环，遍历数组中的所有元素，确认是否能够得到最终的值
> 
> 一种优化的方案是提前对数组进行排序，可以直接跳过一些过大或过小的数值对。

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        const int num_count = static_cast<int>(nums.size());
        for (int i = 0; i < num_count; ++i) {
            for (int j = 0; j < num_count; ++j) {
                if (i != j && nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
        return {};
    }
};
```

时间性能：$O(N^2)$，空间性能：$O(1)$

# 差值映射表

> [!example]- 实现思路
> 利用另一个表（通常是hash表），保存一份值到索引的映射关系。在遍历时，可以直接计算到当前值与目标值之间的差，利用计算出的差值查表，如果存在，这两个值就能组合成目标值，得到结果

```cpp
class Solution {
public:
	vector<int> twoSum(vector<int>& nums, int target) {
		std::unordered_map<int,int> m;
		for (int i = 0; i < static_cast<int>(nums.size()); ++i){
			const int cur_value = nums[i];
			// 计算出当前值与目标值的差
			const int other_value = target - cur_value;
	
			// 查找差值是否已经存在map中，如果能找到，这就是需要找的第一组结果
			const auto iter = m.find(other_value);
			if (iter != m.end()) {
				return {iter->second, i};
			}
	
			m[nums[i]] = i;
		}
	
		return {};
	}
};
```

时间性能：$O(N)$，空间性能：$O(N)$

