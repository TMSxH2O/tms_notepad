
#左值 #右值 #变量 #内存优化 

# 基础

## 左值（Lvalue）和右值（Rvalue）的基础定义

- 左值：<br>具有持久状态的对象，可以取地址，通常出现在赋值运算符左侧。
- 右值：<br>临时对象，没有持久地址，通常出现在赋值语句右侧，其中可以再细分为两类右值<br>**纯右值**，字面量、非引用的函数返回值、lambda表达式等；<br>**将亡值**，通过 `move` 转换得到的右值（或者可以直接说是右值引用），“窃取”了其他变量的内存空间

> [!question] 纯右值和将亡值的区别？
> 主要体现再以下三点：
> - 纯右值没有对应的变量名；
> - 纯右值在当前表达式结束时销毁，而将亡值只是标记了内存可移动；
> - 纯右值不会涉及任何现有对象的所有权转移，而将亡值则是专门用来实现所有权转移提供的特性；

> [!info] 直观理解
> 左值，或者说平时的变量，它可以被视作一段地址的别名，它对应一段具体的内存地址；
> 左值引用，就是左值的别名，直观的表现就是左值引用对象将左值的地址保存起来，修改时直接对地址进行修改；
> 右值，如果是纯右值，则完全没有对应的地址，而将亡值则可以获取对应的地址；
> 右值引用，本质上也是指针，如果是纯右值本身都没有地址，右值引用的做法是将数据先保存到一个地方（通常是栈内的某处），然后引用的指针指向它，将亡值的表现则与左值引用类似；

## 什么是右值引用（Rvalue Reference）？它解决了C++中的什么问题？

使用 `T&&` 表示，绑定到临时对象或可“窃取”资源的对象

解决的问题：

1. 使用移动语句（转移资源而非复制，提升性能）；
2. 支持完美转发（保持参数类型信息），如 `std::vector` 的移动构造避免了复制数组元素；

对象被转换为右值引用，就表示该对象可以被移动。

## 什么是完美转发（Perfect Forwarding）？如何通过 `std::forward` 实现？

完美转发定义：在泛型函数中，将参数按原始的引用类型传递给其他函数。在 `std::forward<T>` 中，会根据 `T` 的类型，对 `T&` 和 `T` 分别使用左引用和有引用传递。

## 如何理解资源转移？

主要是与拷贝进行对比。

所谓拷贝，就是申请一块新的内存空间，将数据复制到新的内存空间中，拷贝生成的两个数据对象间没有关联的。当拷贝的数据类型比较复杂时，消耗较大。

移动就是进行了内部资源的转移，另一个对象直接“窃取”源对象内部的资源。

# 进阶

## 被移动后的对象处于什么状态？

在 C++ 标准中规定，**被移动后的对象（源对象）必须处于“有效但未指定”的状态**。

- **有效**：只对象可以被安全地销毁（析构函数可以正常调用），也可以被重新复制（例如通过构造运算符赋予新资源）。
- **未指定**：指对象原本地资源已经被转移，器内部状态（如指针、大小等）是不确定地，不能依赖它地旧状态进行操作。
