[[Vulkan类关系整理]]

# 类关系整理

## VkGraphPIpelineCreateInfo

- **VkPipelineLayoutCreateInfo**：DescriptionSet的布局信息
- **VkPipelineShaderStageCreateInfo**
- **VkPipelineVertexInputStateCreateInfo**：顶点输入布局
- **VkPipelineColorBlendStateCreateInfo**：指定 Output Merge 的混合设置
- **VkPipelineMultisampleStateCreateInfo**
- **VkPipelineViewportStateCreateInfo**：渲染的视口信息
- **VkRenderPass**：【重要】渲染的Pass

## VkInstance

Vulkan 的实例对象创建时，一些重要的属性

### 实例层级

对应 `VkInstanceCreateInfo` 里的 `ppEnabledLayerNames`

其中一个可能是最常见的使用场景，就是在开启 **校验层**（Validation Layer）时，需要先检查硬件是否支持 `VK_LAYER_KHRONOS_validation`，并开启。这里简要分析以下 UE 的处理方式：

```cpp
class FVulkanInstanceSetupHelper
{
public:
	TArray<FLayerWithExtensions> EnumerateLayerProperties() const
	{
		TArray<FLayerWithExtensions> OutLayerProperties;
TArray<VkLayerProperties> TempLayerProperties;
uint32 Count = 0;
VERIFYVULKANRESULT_INIT(VulkanRHI::vkEnumerateInstanceLayerProperties(&Count, nullptr));
if (Count > 0)
{
	TempLayerProperties.AddZeroed(Count);
	VERIFYVULKANRESULT_INIT(VulkanRHI::vkEnumerateInstanceLayerProperties(&Count, TempLayerProperties.GetData()));
	OutLayerProperties.SetNum(Count);
	for (uint32 i=0; i < Count; ++i)
	{
		// 很多时候（至少VulkanTutorial上），只需要这个数据就够了
		OutLayerProperties[i].LayerProperties = TempLayerProperties[i];
		// 但在UE里，还额外存储了 VkExtensionProperties 的数据
		OutLayerProperties[i].ExtensionProperties = FVulkanInstanceExtension::GetDriverSupportedInstanceExtensions(TempLayerProperties[i].layerName);
	}
}
return OutLayerProperties;
	}
};

TArray<VkExtensionProperties> FVulkanInstanceExtension::GetDriverSupportedInstanceExtensions(const ANSICHAR* LayerName)
{
	TArray<VkExtensionProperties> OutInstanceExtensions;
	uint32 Count = 0;
	VERIFYVULKANRESULT_INIT(VulkanRHI::vkEnumerateInstanceExtensionProperties(LayerName, &Count, nullptr));
	if (Count > 0)
	{
		OutInstanceExtensions.AddZeroed(Count);
		VERIFYVULKANRESULT_INIT(VulkanRHI::vkEnumerateInstanceExtensionProperties(LayerName, &Count, OutInstanceExtensions.GetData()));
	}
	OutInstanceExtensions.Sort([](const VkExtensionProperties& A, const VkExtensionProperties& B) { return FCStringAnsi::Strcmp(A.extensionName, B.extensionName) < 0; });
	return OutInstanceExtensions;
}
```

> [!info] 核心接口
> 这里最后拿到的是两种数据，分别对应两个接口：
> - `VkLayerProperties` 层信息，里面最重要的就是存储了对应层的名字；
> - `VkExtensionProperties` 获取层要求的扩展名和要求的版本；

验证 `EnumerateLayerProperties` 获取到的层，是否支持校验层，如果支持，才会开启。想开启校验层，需要进行以下几个步骤：

- 在创建时，增加额外的层 `VK_LAYER_KHRONOS_validation`；
- 创建 `VkDebugUtilsMessengerCreateInfoEXT` 并添加到 `VkInstanceCreateInfo` 的 `pNext`；
- 根据 `VkDebugUtilsMessengerCreateInfoEXT` 创建 `VkDebugUtilsMessengerEXT`，并注册回调（创建的对象需要在退出前需要销毁 Destroy）

## VkPhysicalDevice

物理设备，以及物理设备信息，用于实现选取GPU逻辑。

### VkPhysicalDeviceProperties

> [!quote] 参考资料
> [Vk 物理设备属性（3） --- VkPhysicalDeviceProperties(3)](https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceProperties.html)

物理设备参数，用于做设备选取的数据。

 - `vendorID` 物理设备供应商的唯一标识符，可以通过查询 [Member Companies | PCI-SIG](https://pcisig.com/membership/member-companies) 找到 ID 对应的厂商（常见的值 Nvidia：4098、Amd：4130、Intel：32902）；
 - `deviceType` 设备类型，用来区分独显、集显、CPU **(?)**；
 - `deviceName` 设备名称；

> [!question] UE（5.5.1） 的 `EGpuVendorId::Amd` 值为 4098？
> 目前推测是UE写错了，在网站搜索，没有看到哪家厂商对应的是 4098。

## VkDevice

## VkSurface


