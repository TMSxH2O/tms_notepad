
#虚拟内存 #物理内存 #内存优化 #缓存

# 基础

## 虚拟内存和物理内存的区别和联系

**区别**：

- 物理内存（RAM）<br>是计算机硬件中实际存在的高速存储设备，通常由 CPU 直接访问，用于存储正在运行的程序和数据，容量受限与硬件配置
- 虚拟内存：<br>是由操作系统提供的内存管理技术，通过软件将物理内存和磁盘交换空间结合，未每个进程创建独立的虚拟地址空间（在 32 位系统中为 4 GB，64 位系统中理论接近 16 EB）

**联系**：

程序在运行时，虚拟地址通过 **页表（Page Table）** 映射到物理内存地址；当物理内存不足时，操作系统会将不常用的 **分页（Page）** 交换到硬盘中，释放空间给当前活跃的数据，实现 “内存扩展”。

因此实际使用的内存依然需要先存放到物理内存中再使用。

## 物理内存存在的问题，为什么需要虚拟内存技术？

物理内存存在以下的问题：

- **容量有限**<br>受到具体的硬件配置影响，而且随着发展，很多软件的大小膨胀迅速，非常容易就会遇到物理内存不够用的情况；
- **内存管理复杂**<br>每个程序在运行过程中申请堆内存，非常容易导致出现内存碎片，使得没有足够得空间去分配后面所需得数据；
- **程序内存访问安全性**<br>在物理内存模式下，每个程序都有可能防卫到其他程序的内存空间（比如写越界时修改到了其他程序的内存），这就存在安全的隐患。

引入虚拟内存，就是为了针对性得解决上面的问题：

- **扩展内存**：<br>虚拟内存可以为每个程序提供与实际物理内存大小无关的一块虚拟内存空间，由操作系统来管理实际哪些内存需要加载到内存，并且卸载掉其他没有用到的内存，来提升内存的利用率。
- **简化内存管理**：<br>虚拟内存使用分页或分段的存储管理方式。在分页存储中，程序的虚拟空间被划分为固定大小的 **分页（Page）**，物理内存也被划分为同样大小的 **页框（Page Frame）**。操作系统通过维护 **页表（Page Table）** 来记录当前虚拟分页和物理内存页框的关系。<br>这种方式让内存管理更加灵活，操作系统只需要在需要用到虚拟内存分页时，将它建在到物理内存的页框中，不需要时清理物理内存的页框，也不需要考虑内存连续性问题。
- **提供内存访问的安全性**：<br>每个程序都只能访问各自独立的虚拟地址空间，操作系统通过内存管理单元（MMU）来实现虚拟地址到物理地址的转换。MMU 会检查每个内存请求，确保程序只能访问自己虚拟地址空间对应的物理内存区域。

## 虚拟内存如何与物理内存协作完成地址转换？

```plantuml
start
:输入虚拟地址;
if (TLB快表中是否缓存了对应的页表) then (存在)
:直接返回页框号;
stop
endif
if (MMU查询页表对应的物理页框号) then (有效)
:MMU 组合物理页框号和业内偏移得到物理地址;
else (无效)
partition "缺页中断" {
:保存当前进程现场（寄存器状态）;
if (检查页面是否存在硬盘（页文件）) then (不存在)
:非法的访问;
stop
endif
partition "分配物理页框" {
if (是否存在空闲的页框) then (不存在) 
:通过页面置换算法（如LRU）选择一个不活跃的页框;
:将不活跃的内框页框，写回硬盘;
:释放该页框，分配给新的分页;
endif
}
:从硬盘读取目标分页到物理页框;
:更新页表;
:更新TLB;
:恢复进程现场，重新执行触发了缺页前的指令;
}
endif
:计算物理地址并访问内存;
end
```

## 在C++中，指针操作的是虚拟内存还是物理内存？

指针操作的是虚拟内存地址；物理内存对程序不可见，由系统控制。

## 什么是 “缺页中断”？频繁发生缺页中断对系统性能由什么影响？

**缺页中断**：当程序访问的虚拟页不在物理内存中时，CPU触发的中断，操作系统需要将对应的页从硬盘加载到内存后再恢复程序执行

**性能影响**：硬盘的 I/O 速度远低于内存（通常有10万量级的性能差异），单次缺页中断可能耗时数十微妙，频繁缺页会导致程序的运行速度大幅降低。


