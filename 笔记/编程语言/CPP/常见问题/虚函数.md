
#虚函数 #面向对象 

# 基础

## 什么函数可以/不可以声明为虚函数？

以下可以被声明为虚函数：

- 普通成员函数：通常通过将基类的成员函数声明为虚函数，可以实现多态性
- 析构函数：通常需要将基类的析构函数声明为虚函数，来确保删除派生类对象时正确调用析构函数，避免内存泄漏

以下不可以被声明为虚函数：

- 静态成员函数：静态成员函数属于类不属于类对象，因此不能设定为虚函数
- 全局函数：全局函数不属于任何类，因此不能是虚函数
- 友元函数：友元函数是独立于类，因此不能是虚函数
- 内联函数：内联函数的预期是在编译直接展开，没有虚函数的动态绑定和多态性特性
- 构造函数：构造函数在对象构造时被调用，无法使用相同绑定的多态性（构造函数内无法确认当前的对象类型）

> [!info] 补充
> - 纯虚函数：在基类中声明为纯虚函数（没有实现的虚函数）。纯虚函数会使得基类，以及没有实现的子类，都成为抽象类，无法实例化对象。
> - 虚函数的默认参数：虚函数可以包含默认参数，但必须要注意参数的值在调用时将使用静态绑定，而不是动态绑定。

## C++的多态是如何实现的？

C++ 的多态是利用虚函数表（vtable）和虚函数指针（vptr）实现，核心是 **动态绑定**（运行时确定调用的函数），具体过程如下：

1. 虚函数表（vtable）<br>当类中的函数被声明为虚函数时，编译器会为该类生成一张虚函数表（函数指针的数组），存储该类所有虚函数的地址。如果派生类中重载了虚函数，派生类的虚函数表中存储的就是重载的函数地址；否则，没有重载就继续沿用基类的函数地址。
2. 虚函数指针（vptr）<br>每个包含虚函数的类对象中，都会存储一个虚函数指针，指向该类型的虚函数表。虚函数指针通常存储在对象的开头（取决于编译器）。虚函数指针在每个类的构造器中被设置，使其指向该类的虚函数表（析构也类似），所以在构造和析构中无法使用虚函数。
3. 动态绑定过程<br>通过基类指针 / 引用时，编译器会通过对象的虚函数指针来找到对应的虚函数表，去调用实际需要的函数，从而实现 “同一调用语句，不同对象执行不同逻辑” 的多态效果。
