
# 题目描述

> [!tag]- 标签
> #设计 #双指针 #数据流 #排序 #堆（优先队列）

[295. 数据流的中位数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-median-from-data-stream/description/?envType=study-plan-v2&envId=top-100-liked)

![[LeetCode-FindMedianFromDataStream.png|600]]

# 使用大小堆分别存储一半的数据

> [!example]- 实现思路
> 使用一个最大堆和一个最小堆，按照大小分别存储一半的数据。其中，比中位数小的值都保存再最大堆中，剩下的，比中位数大的值就都在最小堆中。通过这样的划分，最大堆和最小堆拿到的数据，肯定都是最接近中位数的值。
> 
> 之后为了处理单数的情况，这里可以做一个约定，比如最大堆（小的那一半）永远比最小堆的长度多 1。这样，当两个堆的长度不一致时（一致就是偶数，两个取中间堆的 `top` 平均值），就可以直接使用最大堆的 `top` 值。

```cpp
class MedianFinder {
	// 约定，最大堆的数量永远等于最小堆或比最小堆的数量多1
	// 最大堆保存的是小于中位数的一半数据
    std::priority_queue<int, std::vector<int>, std::less<>> m_max_heap;
    // 最小堆保存的是大于中位数的一半数据
    std::priority_queue<int, std::vector<int>, std::greater<>> m_min_heap;
  
public:
    MedianFinder() = default;
    
    void addNum(int num)
    {
        // 当最大堆为空，或者输入值小于中位数，就优先插入最大堆
        if (m_max_heap.empty() || num <= m_max_heap.top()) {
            m_max_heap.push(num);

			// 当最大堆的数量超出了最小堆数量+1，需要把当前的最大堆堆顶数据分到最小堆
            if (m_max_heap.size() > m_min_heap.size() + 1) {
                m_min_heap.push(m_max_heap.top());
                m_max_heap.pop();
            }
        }
        // 输入值大于中位数，就应该优先插入最小堆
        else {
            m_min_heap.push(num);
            
			// 如果最小堆的数量大于最大堆，不符合约定，需要把最小堆的堆顶数据分到最大堆
            if (m_min_heap.size() > m_max_heap.size()) {
                m_max_heap.push(m_min_heap.top());
                m_min_heap.pop();
            }
        }
    }
    
    double findMedian() {
	    // 总数为偶数的情况，需要取最接近中心的两个数据的平均值
        if (m_max_heap.size() == m_min_heap.size()) {
            return (m_min_heap.top() + m_max_heap.top()) * 0.5;
        }
        // 总数为单数的情况，由于上面的约定，这个值永远是保存在最大堆的堆顶
        return m_max_heap.top();
    }
};
```

时间性能：
- `addNum` $O(logN)$；
- `findMedian` $O(1)$；
空间性能：$O(N)$

## 使用有序集合与左右指针

> [!example]- 实现思路
> 利用有序数据结构（针对这个问题，需要用到 `multiset`），在插入后根据当前数据数量，可以分以下情况：
> - 插入后有偶数个数据：<br>左右指针需要变为指向不同的值，根据插入数据大小，分别左移 `left` 或者右移 `right` 解决；
> - 插入后有奇数个数据：<br>左右指针需要指向同一个值，根据插入数据大小，变为 `left` 或者 `right` 指针；

```cpp
class MedianFinder {
    std::multiset<int> m_nums;
    std::multiset<int>::const_iterator left, right;
  
public:
    MedianFinder()
        : left(m_nums.cend()), right(m_nums.cend())
    {}
    
    void addNum(int num)
    {
	    // 保存的是原本的值（其实用当前值也没啥问题，第一个判断改成 num_count == 1就行）
        const size_t num_count = m_nums.size();
        m_nums.insert(num);
  
        if (num_count == 0) {
            left = right = m_nums.begin();
        }
        // 偶数的情况，需要考虑左移left或者右移right
        else if (num_count & 1) {
            if (num < *left) {
                --left;
            }
            else {
                ++right;
            }
        }
        // 奇数的情况，需要将left、right都变为指向最中心的值
        else {
            if (num < *left)
            {
                left = --right;
            }
            else {
                right = ++left;
            }
        }
    }
    
    double findMedian()
    {
	    // 其实也可以判断left是否等于right，就能少计算一次取平均值，直接返回left或者right的值
        return (*left + *right) * 0.5;
    }
};
```

时间性能：
- `addNum` $O(logN)$
- `findMedian` $O(1)$
空间性能：$O(N)$
