
#操作系统 #进程 #线程 #协程 #线程安全

# 基础

## 介绍一下什么是进程（Process）？

**定义**：进程时操作系统进行资源分配和调度的基础单位，是一个独立运行的程序实例，拥有独立的内存空间、文件描述符、寄存器状态等系统资源。

**在 C++ 中的特点**：

- 创建方式： C++ 本身没有直接创建进程的标准库接口，需要依赖操作系统API。例如：
	- Linux/Unix：通过 `fork()` 系统调用创建子进程（复制父进程资源），配合 `exec()` 系列函数加载新程序；
	- Windows：通过 `CreateProcess()` 函数创建进程；
- 资源隔离：进程间内存空间完全独立，默认无法直接共享数据，需要通过进程间的通信机制来共享数据。
- 通信方式：需要依赖操作系统的 IPC（进程间通信）机制，如管道（Pipe）、信号量（Semaphore）、共享内存（shared memory）、信息队列、套接字（socket）等。C++中可通过封装这些系统调用实现通信（例如使用 C++17 中支持的共享内存 `std::shared_memory_object`）。
- 开销：进程的创建和销毁开销较大（需分配/释放独立资源），上下文切换的成本高（需切换页表、寄存器等内核态资源）。

**适用场景**：

- 需完全隔离的任务（如独立的应用程序）；
- 利用多核 CPU 进行粗粒度并行（但通信成本高）；

## 介绍一下什么是线程（Thread）？

**定义**：线程是进程内的执行单元，共享所属进程的内存空间（代码段、数据段、堆等），拥有独立的栈和寄存器状态。一个进程可以包含多个线程，线程是操作系统调度的基本单位（抢占式调度）。

**在 C++ 中的特点**：

- 标准支持：C++11 引入了 `std::thread` 作为标准线程库，封装了平台特定的线程实现（如 Linux 的 pthread、Windows 的 Win32 线程），提供了跨平台的线程创建和管理接口。
- 资源共享和同步：线程共享进程内存，因此可通过全局变量、堆内存直接通信，但需要同步机制避免数据竞争。C++ 标准库提供了 `std::mutex`（互斥锁）、`std::condition_variable`（条件变量）、`std::atomic`（原子操作）等同步工具。
- 调度：由操作系统内核调度（抢占式），线程的切换由内核决定（如时间片用完或 IO 阻塞时），切换成本中等（需保存 / 恢复栈和寄存器，但无需切换页表）。
- 限制：线程数量有限（受系统内存和内核限制），过多的线程会导致频繁进行上下文切换，降低运行效率。

```cpp
#include <thread>
void task() { /* 线程执行的任务 */ }
int main() {
    std::thread t(task); // 创建线程
    t.join(); // 等待线程结束
    return 0;
}
```

**适用场景**：

- 多核 CPU 的并行计算（如数据计算、数据处理）；
- 需要并发处理多个任务，且任务间由数据共享的场景（如服务器处理多个客户端的请求）；

> [!question] 扩展一些线程安全的问题
> **TODO**

## 什么是线程安全？多线程面临哪些问题？

线程安全的具体体现就是，使用多线程实现的代码，最后执行的效果可以像单线程一样正确。

### 多线程的问题

*数据竞争* data race

定义：当多个线程同时修改共享的资源时，可能会出现数据的不一致问
题；

解决：

1. 利用锁或其他机制（比如CAS），限制代码的逻辑，不会同时修改共享的数据；
2. 利用原子类，利用系统的 CAS 命令，来保证只有当原本的数据是预期的值时，才进行修改，也能保证数据的一致性；

> [!info] 扩展
> 数据竞争不只是几个线程的目标值相互覆盖，还可能出现一些完全不明所以的值。原因是一个写操作可能对应多条指令，在多线程环境下，就可能出现多条指令被拆分乱序执行，最后得到一个拼接出的值。

---

 *死锁* dead lock
 
 定义：多个线程互相等待对方已占有的资源，导致线程持续等待无法继续执行逻辑；

解决：

- 控制加锁的顺序，可以考虑使用 `std::lock` 接口，来确保加锁的顺序一致；
- 可以使用 `try_lock_for` 设置超时，并在失败后回退重试；

> [!info] 扩展 - 活锁 Live lock
> **定义**：活锁表示的是，在使用超时回退的处理时，可能出现几个线程反复回退，重新执行时又遇到资源被占用，然后几个线程反复超时回退重复执行的情况。严格来说并没有死锁，但同样无法推进逻辑执行。
> 
> **解决方案**：增加随机的休眠时间，错开几个线程的重试时间，避免一直重复遇到占用资源的情况。

---

 *内存同步问题* memory synchronization
 
 定义：确保内存的可见性，即一个线程堆内存的修改，可能无法被其他线程及时感知到；

解决：

- 通过设置内存顺序，来保证内存数据的可见性，使用 memory barrier 或原子类，指定 memory order 来确保读写数据的顺序；
- 使用条件变量，在数据更新时唤醒；

---

 *虚假唤醒* spurious wakeup
 
 定义：等待条件变量的线程可能无缘无故被唤醒，即使条件还未满足；

解决：增加条件循环，来确保已经满足了条件，才往后执行逻辑；

## 详细介绍一下

# 扩展

## 介绍一下什么是协程（Coroutine）？

**定义**：协程是用户态的轻量级 “线程”，由程序自身（而非操作系统内核）控制调度（非抢占式），可在执行过程中主动暂停（yield）和恢复（resume），共享所属线程的资源。

**在 C++ 中的特点**：

- 标准支持：C++20 中正式引入协程标准，通过 `co_await`（等待异步操作）、`co_yield`（返回中间结果并暂停）、`co_return`（结束协程）等关键字实现。
- 调度方式：非抢占式调度，许仙是调用 `co_await`、`co_yield` 来触发切换，在用户态下完成（无需内核介入），成本较低（仅保存 / 恢复少量上下文，如程序计数器、局部变量）。
- 资源暂用：协程栈通常很小（可动态增长），一个线程可承载数万甚至数十万协程，适合高并发场景。
- 依赖：C++ 协程本身仅定义了语法和框架，需适配具体的异步库（如 `libunifex`、`asio`）实现功能（如异步IO、事件循环）。C++20 前可通过 Boost.Coroutine 等第三方库使用协程。

```cpp
#include <coroutine> 

// 简化的协程示例（需要配套的promise类型） 
generator<int> count_up_to(int max) 
{ 
	for (int i = 0; i <= max; ++i) { 
		co_yield i; // 暂停并返回i，下次恢复从这里继续 
	} 
}
```

**适用场景**：

- IO 密集型任务（如网络服务器、数据库操作），避免线程因 IO 阻塞而闲置；
- 高并发场景（如处理百万级并发连接）；
- 状态机、迭代器需要 “暂停 - 恢复” 逻辑的场景；

## 展开介绍一下进程间的通信方式？

### 1.**管道 / 匿名管道**（Pipe）

**特点**：

- 半双工（单向通信），只能父子进程或亲缘进程间使用；
- 基于文件描述符，数据在内存中传递，无持久化存储；

```cpp
#include <iostream>
#include <unistd.h>
#include <cstring>
#include <wait.h>

int main() {
    int pipefd[2]; // 管道文件描述符：[0]读端，[1]写端
    if (pipe(pipefd) == -1) {
        perror("pipe failed");
        return 1;
    }

    pid_t pid = fork(); // 创建子进程
    if (pid == -1) {
        perror("fork failed");
        return 1;
    }

    if (pid == 0) { // 子进程：读数据
        close(pipefd[1]); // 关闭写端（只需要读）
        char buf[1024];
        ssize_t n = read(pipefd[0], buf, sizeof(buf)-1);
        if (n > 0) {
            buf[n] = '\0';
            std::cout << "子进程收到：" << buf << std::endl;
        }
        close(pipefd[0]);
        return 0;
    } else { // 父进程：写数据
        close(pipefd[0]); // 关闭读端（只需要写）
        const char* msg = "Hello from parent!";
        write(pipefd[1], msg, strlen(msg));
        close(pipefd[1]);
        wait(nullptr); // 等待子进程结束
        return 0;
    }
}
```

### 2.**命名管道**（FIFO）

**特点**：

- 可在任意进程间通信（无需亲缘关系，全双工），通过文件系统中的路径标识交互；
- 数据传递方式同管道，但需显式创建和删除管道文件；

```cpp
// 写进程（writer.cpp）
#include <iostream>
#include <fstream>
#include <string>

int main() {
    const std::string fifo_path = "/tmp/my_fifo";
    // 创建FIFO（若已存在则忽略错误）
    mkfifo(fifo_path.c_str(), 0666);

    // 打开FIFO写入数据
    std::ofstream fifo(fifo_path, std::ios::out);
    if (!fifo.is_open()) {
        std::cerr << "无法打开FIFO" << std::endl;
        return 1;
    }

    fifo << "Hello from FIFO writer!" << std::endl;
    fifo.close();
    return 0;
}

// ==============================================
// 读进程（reader.cpp）
#include <iostream>
#include <fstream>
#include <string>

int main() {
    const std::string fifo_path = "/tmp/my_fifo";
    std::ifstream fifo(fifo_path, std::ios::in);
    if (!fifo.is_open()) {
        std::cerr << "无法打开FIFO" << std::endl;
        return 1;
    }

    std::string msg;
    std::getline(fifo, msg);
    std::cout << "收到数据：" << msg << std::endl;
    fifo.close();
    return 0;
}
```

### 3.**共享内存**（Shared Memory）

**特点**：

- 进程间共享一块物理内存，是效率最高的 IPC 方式（无数据拷贝）；
- 需要同步机制（如信号量）防止数据竞争；

```cpp
#include <iostream>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <cstring>

int main() {
    const char* shm_name = "/my_shared_memory";
    const size_t shm_size = 1024;

    // 创建/打开共享内存
    int shm_fd = shm_open(shm_name, O_CREAT | O_RDWR, 0666);
    if (shm_fd == -1) {
        perror("shm_open failed");
        return 1;
    }

    // 设置共享内存大小
    ftruncate(shm_fd, shm_size);

    // 映射到进程地址空间
    void* shm_ptr = mmap(nullptr, shm_size, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shm_ptr == MAP_FAILED) {
        perror("mmap failed");
        return 1;
    }

    // 写入数据（父进程）或读取数据（子进程）
    pid_t pid = fork();
    if (pid == 0) { // 子进程：读
        std::cout << "共享内存数据：" << (char*)shm_ptr << std::endl;
    } else { // 父进程：写
        const char* msg = "Hello from shared memory!";
        strncpy((char*)shm_ptr, msg, shm_size);
        wait(nullptr);
    }

    // 清理
    munmap(shm_ptr, shm_size);
    close(shm_fd);
    shm_unlink(shm_name); // 最后一个进程删除共享内存
    return 0;
}
```

### 4.**信号量**（Semaphore）

**特点**：

- 并非用于传输数据，而是用于进程 / 线程间的同步和互斥（如控制共享资源访问）；
- 本质是一个计数器，支持等待（数据减一）和释放（数据加一）操作；

```cpp
// 进程A
#include <windows.h>

int main()
{
	// 调用系统接口创建信号量，这里设置了最大值为10，说明最多同时触发10次释放
	// 参数解析：
	// 1.安全属性，如果没有特殊需求，通常使用NULL
	// 2.可用资源数目，就是信号量的初始值
	// 3.信号量对象可处理的最大资源数，就是最大值
	// 4.信号量的名称，进程之间可共享
	HANDLE handle = CreateSemaphore(NULL, 0, 10, "Semaphore");
	
	...
	
	// 调用等待，触发信号量的值减1，当信号量的值大于0时等待，一直等待到超时，或信号量的值小于等于0
	// 参数解析：
	// 1.信号量的句柄
	// 2.超时时间，单位为毫秒
	DWORD ret = WaitForSingleObject(handle, 10000);

	// 释放信号量，触发信号量的值加1，当使用了信号量控制的优先资源后，都应该调用释放
	// 参数解析：
	// 1.信号量的句柄
	// 2.释放使用的资源数（增加的值），必须大于0且不大于信号量指定的最大值
	// 3.获取释放前的资源计数
	ReleaseSemaphore(handle, 1, NULL);

	... 

	// 关闭句柄对应的资源，此处传入信号量句柄，就是关闭（删除）信号量
	CloseHandle(handle);
}
```

