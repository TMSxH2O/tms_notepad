
#内存 #栈 #堆 #全局变量 #大小端

# 基础

## 什么是大小端？

> 表示对于多byte数据，将byte按照高位在前保存在内存高地址（小端）和低位在前保存在内存高地址（大端）的方式存储。
>
> 举个具体的例子，在64位系统中，`uint16_t` 的大小是2byte，那么数值 `0x1234` 在内存中分为两个 byte，`0x12` 和 `0x34`，其中 `0x12` 就是数据的更高位。
> 
> 那么，在小端存储的系统中，数据保存如下：
> ```
> 低地址 --> 高地址
>   0x34 | 0x12
> ```
> 相对的，在大端存储的系统中，数据保存如下：
> ```
> 低地址 --> 高地址
>   0x12 | 0x34
> ```

大小端像两种书写习惯：大端像正常写字（高位在前），小端像倒着写（低位在前）。比如数字0x1234：

- 大端：内存中按顺序存0x12、0x34（类似"一二三四"正常书写）
- 小端：内存中倒序存0x34、0x12（类似"四三二一"逆向书写）  

实际数值相同，但存储顺序相反，就像同一串数字正反两种写法。

> [!example] 示例
> Windows 中的示例，使用小端存储
> ![[内存布局-Windows内存示例.png|400]]

## C++ 程序的内存空间通常分为哪几个主要区域？每个区域分别存储什么类型的数据？

C++ 内存空间通常被分为四个核心区域：

1. 栈区<br>存储局部变量、函数参数以及临时对象，由编译器自动分配和释放，准寻后进先出的原则。
2. 堆区<br>存储通过 `new`/`delete` 动态分配的对象，由程序员手动管理生命周期，内存分配灵活但效率较低。
3. 全局/静态区<br>存储全局变量和静态局部变量，生命周期为程序远程，内部对象的初始化在编译期或运行初期，静态局部变量则是在运行调用时触发初始化。
4. 代码区<br>存储编译后的可执行代码以及字面量（代码里写死的数值，或是字符串），属性为只读。

> [!tip] 进阶
> 全局/静态区可以进一步划分，分为：
> -  `.rodata` 只读数据，如果对这部分内存的数据进行修改，将触发未定义行为（Debug 下会直接触发报错 Segmentation Fault），相对的 `.data` 内的数据则允许进行修改
> - `.data` 已经初始化的全局/静态变量
> - `.bss` 未初始化的全局/静态变量（在程序启动时先对整个区域清零）

## 栈区和堆区在内存分配方式、管理方式、生长方向上有什们主要区别？为什么栈上的内存分配效率通常更高？


| 对比维度 | 栈区                      | 堆区                          |
| ---- | ----------------------- | --------------------------- |
| 分配方式 | 编译器自动分配（如函数调用时自动分配局部变量） | 程序员手动调用 `new`/`delete` 动态分配 |
| 内存管理 | 自动释放（离开变量生命周期时自动销毁）     | 需手动释放，否则可能导致内存泄露            |
| 生长方向 | 由高地址向低地址生长（从栈底开始扩展）     | 从低地址向高地址生长（向空闲内存扩展）         |
| 碎片问题 | 无碎片（栈帧连续释放）             | 可能产生内存碎片（多次分配/释放不连续）        |
| 分配效率 | 高（仅移动栈指针）               | 较低（需查询内存管理链表、触发系统调用）        |

> [!example] 追问
> **栈效率高的原因？**
> 栈的分配/释放时简单的指针操作（如 x64 的 rsp 寄存器）和触发析构（如果需要的话），无需复杂的内存查找和状态维护；
> 而堆需要通过内存分配器（如 `ptmalloc`）处理空闲块管理，设计系统调用或复杂算法。

# 进阶

## 堆内存泄露的常见场景有哪些？如何通过 C++ 的语言特性避免内存泄露？

常见的内存泄露场景：

1. 忘记调用 `delete`: `new` 分配后未匹配 `delete`
2. 重复调用 `delete`：对同一个指针多次调用析构，导致未定义行为
3. 数组和指针不匹配：`new[]` 分配的数组用 `delete` 释放（应该使用 `delete[]`）
4. 异常安全问题：`new` 到 `delete` 之间的逻辑，抛出了异常，内存未释放

解决方案：利用 `RAII`（资源获取即初始化）来解决

- 使用 **智能指针** 来代替原始指针（或者叫裸指针），自动管理内存的释放
- 使用自定义资源管理类，在构造函数中分配资源，析构函数中释放（如文件句柄、网络链接）

## C++11引入的 `constexpr` 变量和 `const` 全局变量分别存储在哪个区域？

- `constexpr` 变量：<br>*存储区域*：只读数据段（`.rodata`，**全局/静态区**）或 **代码区**<br>*原因*：`constexpr` 必须用编译时常量表达式初始化，其值在编译期完全确定。若需要分配内存（如取地址操作），则存放在只读数据段；否则可能被编译器内联优化，保存在代码区
- `const` 全局变量：<br>*情况1*：若用常量表达式初始化（如 `const int x = 42`），则行为与 `constexpr` 一致，通常保存在只读数据段（**全局/静态区**）中。<br>*情况2*：若需要运行时计算（如 `const int y = some_function()`），则存储在数据段中，初始化完成后被视为只读<br>*原因*：运行时初始化的 `const` 全局变量需要在程序启动时通过代码初始化，因此必须分配在可写区域。但语言规定可以保证其不可进行修改，物理内存是否可写由实现决定，修改会导致未定义行为。

> [!warning] 注意
> 这里需要注意 `const` 变量，是有可能保存在 `.data` 的。由于 `.rodata` 和 `.data` 两个区域的差异。在 `.data` 里的变量可以强行修改而不会触发报错。
> ```cpp
> const int g_constexpr_value = 100;  // 编译期可以确定结果的常量，对象保存在 可读数据段rodata 中
> const int g_const_value = GetConstValue();  // 在初始化需要进行计算，为了保证可写，数据会被保存在 全局/静态区.data 中
> void main()
> {
> 	// 尝试对 .rodata 内的数据进行修改，将会触发崩溃
> 	{
> 		auto& v = const_cast<int&>(g_constexpr_value);
> 		v = 200;  // 触发崩溃
> 	}
> 	// 尝试对 .data 内的数据进行修改，不会触发崩溃
> 	{
> 		auto& v = const_cast<int&>(g_const_value);
> 		v = 200;  // 正常执行，无崩溃
> 	}
> }
> ```

## 现代C++中，如何利用内存分区特性优化程序性能？

性能优化示例：

1. 利用栈的高速访问：将高频使用的小对象（如临时计算变量）放在栈上，避免堆分配开销。（例如使用 `std::array` 固定长度的数组，分配的是栈上的内存）
2. 减少堆碎片化：通过对象池（Object Pool）复用堆内存，避免频繁 `new`/`delete` 操作
3. 数据局部性优化：将相关数据连续存储在栈或全局区，利用CPU缓存预取避免预取，避免堆上分散分配（本质就是让相关的数据尽量放在一起，减少缓存未命中，和放的地方关系不会特别大）
4. 只读数据隔离：将字符串字面量、const 变量放在代码区，避免意外修改
